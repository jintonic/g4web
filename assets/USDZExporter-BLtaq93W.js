import"./three-module-Bgl_dleh.js";import{s as S,z as k}from"./three-editor-CtR3j_K9.js";import{y as A,o as v,b0 as D}from"./three-core-B2VhXfyC.js";class ${constructor(r,e="",n=[],o=[]){this.name=r,this.type=e,this.metadata=n,this.properties=o,this.children=[]}addMetadata(r,e){this.metadata.push({key:r,value:e})}addProperty(r,e=[]){this.properties.push({property:r,metadata:e})}addChild(r){this.children.push(r)}toString(r=0){const e="	".repeat(r),n=this.metadata.map(c=>{const y=c.key,f=c.value;if(Array.isArray(f)){const p=[];return p.push(`${y} = {`),f.forEach(g=>{p.push(`${e}		${g}`)}),p.push(`${e}	}`),p.join(`
`)}else return`${y} = ${f}`}),o=n.length?` (
${n.map(c=>`${e}	${c}`).join(`
`)}
${e})`:"",s=this.properties.map(c=>{const y=c.property,f=c.metadata.length?` (
${c.metadata.map(p=>`${e}		${p}`).join(`
`)}
${e}	)`:"";return`${e}	${y}${f}`}),i=this.children.map(c=>c.toString(r+1)),a=[];if(s.length>0&&a.push(...s),i.length>0){s.length>0&&a.push("");for(let c=0;c<i.length;c++)a.push(i[c]),c<i.length-1&&a.push("")}const d=a.join(`
`),l=this.type?this.type+" ":"";return`${e}def ${l}"${this.name}"${o}
${e}{
${d}
${e}}`}}class J{constructor(){this.textureUtils=null}setTextureUtils(r){this.textureUtils=r}parse(r,e,n,o){this.parseAsync(r,o).then(e).catch(n)}async parseAsync(r,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,onlyVisible:!0,quickLookCompatible:!1,maxTextureSize:1024},e);const n=new Set,o={},s="model.usda";o[s]=null;const i=new $("Root","Xform"),a=new $("Scenes","Scope");a.addMetadata("kind",'"sceneLibrary"'),i.addChild(a);const d="Scene",l=new $(d,"Xform");l.addMetadata("customData",["bool preliminary_collidesWithEnvironment = 0",`string sceneName = "${d}"`]),l.addMetadata("sceneName",`"${d}"`),e.includeAnchoringProperties&&(l.addProperty(`token preliminary:anchoring:type = "${e.ar.anchoring.type}"`),l.addProperty(`token preliminary:planeAnchoring:alignment = "${e.ar.planeAnchoring.alignment}"`)),a.addChild(l);let c;const y={},f={};T(r,l,y,n,o,e);const p=X(y,f,e.quickLookCompatible);c=E()+`
`+i.toString()+`

`+p.toString(),o[s]=S(c),c=null;for(const M in f){let x=f[M];if(x.isCompressedTexture===!0){if(this.textureUtils===null)throw new Error("THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.");x=await this.textureUtils.decompress(x)}const m=I(x.image,x.flipY,e.maxTextureSize),P=await new Promise(h=>m.toBlob(h,"image/png",1));o[`textures/Texture_${M}.png`]=new Uint8Array(await P.arrayBuffer())}let g=0;for(const M in o){const x=o[M],m=34+M.length;g+=m;const P=g&63;if(P!==4){const h=64-P,U=new Uint8Array(h);o[M]=[x,{extra:{12345:U}}]}g=x.length}return k(o,{level:0})}}function N(t,r){let e=t.name;return e=e.replace(/[^A-Za-z0-9_]/g,""),/^[0-9]/.test(e)&&(e="_"+e),e===""&&(t.isCamera?e="Camera":e="Object"),r.has(e)&&(e=e+"_"+t.id),r.add(e),e}function I(t,r,e){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const n=e/Math.max(t.width,t.height),o=document.createElement("canvas");o.width=t.width*Math.min(1,n),o.height=t.height*Math.min(1,n);const s=o.getContext("2d");return r===!0&&(s.translate(0,o.height),s.scale(1,-1)),s.drawImage(t,0,0,o.width,o.height),o}else throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const u=7;function E(){return`#usda 1.0
(
	customLayerData = {
		string creator = "Three.js USDZExporter"
	}
	defaultPrim = "Root"
	metersPerUnit = 1
	upAxis = "Y"
)
`}function T(t,r,e,n,o,s){for(let i=0,a=t.children.length;i<a;i++){const d=t.children[i];if(d.visible===!1&&s.onlyVisible===!0)continue;let l;if(d.isMesh){const c=d.geometry,y=d.material;if(y.isMeshStandardMaterial){const f="geometries/Geometry_"+c.id+".usda";if(!(f in o)){const p=z(c);o[f]=S(E()+`
`+p.toString())}y.uuid in e||(e[y.uuid]=y),l=Z(d,c,e[y.uuid],n)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",d)}else d.isCamera?l=j(d,n):l=R(d,n);l&&(r.addChild(l),T(d,l,e,n,o,s))}}function R(t,r){const e=N(t,r);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const n=new $(e,"Xform");if(t.pivot!==null){const o=t.position,s=t.quaternion,i=t.scale,a=t.pivot;n.addProperty(`float3 xformOp:translate = (${o.x.toPrecision(u)}, ${o.y.toPrecision(u)}, ${o.z.toPrecision(u)})`),n.addProperty(`float3 xformOp:translate:pivot = (${a.x.toPrecision(u)}, ${a.y.toPrecision(u)}, ${a.z.toPrecision(u)})`),n.addProperty(`quatf xformOp:orient = (${s.w.toPrecision(u)}, ${s.x.toPrecision(u)}, ${s.y.toPrecision(u)}, ${s.z.toPrecision(u)})`),n.addProperty(`float3 xformOp:scale = (${i.x.toPrecision(u)}, ${i.y.toPrecision(u)}, ${i.z.toPrecision(u)})`),n.addProperty('uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:translate:pivot", "xformOp:orient", "xformOp:scale", "!invert!xformOp:translate:pivot"]')}else{const o=O(t.matrix);n.addProperty(`matrix4d xformOp:transform = ${o}`),n.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]')}return n}function Z(t,r,e,n){const o=R(t,n);return o.addMetadata("prepend references",`@./geometries/Geometry_${r.id}.usda@</Geometry>`),o.addMetadata("prepend apiSchemas",'["MaterialBindingAPI"]'),o.addProperty(`rel material:binding = </Materials/Material_${e.id}>`),o}function O(t){const r=t.elements;return`( ${C(r,0)}, ${C(r,4)}, ${C(r,8)}, ${C(r,12)} )`}function C(t,r){return`(${t[r+0]}, ${t[r+1]}, ${t[r+2]}, ${t[r+3]})`}function z(t){const r=new $("Geometry"),e=H(t);return r.addChild(e),r}function H(t){const r="Geometry",e=t.attributes,n=e.position.count,o=new $(r,"Mesh");o.addProperty(`int[] faceVertexCounts = [${L(t)}]`),o.addProperty(`int[] faceVertexIndices = [${V(t)}]`),o.addProperty(`normal3f[] normals = [${_(e.normal,n)}]`,['interpolation = "vertex"']),o.addProperty(`point3f[] points = [${_(e.position,n)}]`);for(let i=0;i<4;i++){const a=i>0?i:"",d=e["uv"+a];d!==void 0&&o.addProperty(`texCoord2f[] primvars:st${a} = [${G(d)}]`,['interpolation = "vertex"'])}const s=e.color;return s!==void 0&&o.addProperty(`color3f[] primvars:displayColor = [${_(s,n)}]`,['interpolation = "vertex"']),o.addProperty('uniform token subdivisionScheme = "none"'),o}function L(t){const r=t.index!==null?t.index.count:t.attributes.position.count;return Array(r/3).fill(3).join(", ")}function V(t){const r=t.index,e=[];if(r!==null)for(let n=0;n<r.count;n++)e.push(r.getX(n));else{const n=t.attributes.position.count;for(let o=0;o<n;o++)e.push(o)}return e.join(", ")}function _(t,r){if(t===void 0)return console.warn("USDZExporter: Normals missing."),Array(r).fill("(0, 0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),s=t.getY(n),i=t.getZ(n);e.push(`(${o.toPrecision(u)}, ${s.toPrecision(u)}, ${i.toPrecision(u)})`)}return e.join(", ")}function G(t){const r=[];for(let e=0;e<t.count;e++){const n=t.getX(e),o=t.getY(e);r.push(`(${n.toPrecision(u)}, ${1-o.toPrecision(u)})`)}return r.join(", ")}function X(t,r,e=!1){const n=new $("Materials");for(const o in t){const s=t[o];n.addChild(B(s,r,e))}return n}function B(t,r,e=!1){const n=new $(`Material_${t.id}`,"Material");function o(i,a,d){const l=i.source.id+"_"+i.flipY;r[l]=i;const c=i.channel>0?"st"+i.channel:"st",y={1e3:"repeat",1001:"clamp",1002:"mirror"},f=i.repeat.clone(),p=i.offset.clone(),g=i.rotation,M=Math.sin(g),x=Math.cos(g);p.y=1-p.y-f.y,e?(p.x=p.x/f.x,p.y=p.y/f.y,p.x+=M/f.x,p.y+=x-1):(p.x+=M*f.x,p.y+=(1-x)*f.y);const m=new $(`PrimvarReader_${a}`,"Shader");m.addProperty('uniform token info:id = "UsdPrimvarReader_float2"'),m.addProperty("float2 inputs:fallback = (0.0, 0.0)"),m.addProperty(`string inputs:varname = "${c}"`),m.addProperty("float2 outputs:result");const P=new $(`Transform2d_${a}`,"Shader");P.addProperty('uniform token info:id = "UsdTransform2d"'),P.addProperty(`float2 inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${a}.outputs:result>`),P.addProperty(`float inputs:rotation = ${(g*(180/Math.PI)).toFixed(u)}`),P.addProperty(`float2 inputs:scale = ${b(f)}`),P.addProperty(`float2 inputs:translation = ${b(p)}`),P.addProperty("float2 outputs:result");const h=new $(`Texture_${i.id}_${a}`,"Shader");return h.addProperty('uniform token info:id = "UsdUVTexture"'),h.addProperty(`asset inputs:file = @textures/Texture_${l}.png@`),h.addProperty(`float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${a}.outputs:result>`),d!==void 0&&h.addProperty(`float4 inputs:scale = ${F(d)}`),a==="normal"&&(h.addProperty("float4 inputs:scale = (2, 2, 2, 1)"),h.addProperty("float4 inputs:bias = (-1, -1, -1, 0)")),h.addProperty(`token inputs:sourceColorSpace = "${i.colorSpace===D?"raw":"sRGB"}"`),h.addProperty(`token inputs:wrapS = "${y[i.wrapS]}"`),h.addProperty(`token inputs:wrapT = "${y[i.wrapT]}"`),h.addProperty("float outputs:r"),h.addProperty("float outputs:g"),h.addProperty("float outputs:b"),h.addProperty("float3 outputs:rgb"),(t.transparent||t.alphaTest>0)&&h.addProperty("float outputs:a"),[m,P,h]}t.side===A&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t);const s=new $("PreviewSurface","Shader");if(s.addProperty('uniform token info:id = "UsdPreviewSurface"'),t.map!==null?(s.addProperty(`color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?s.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(s.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),s.addProperty(`float inputs:opacityThreshold = ${t.alphaTest}`)),o(t.map,"diffuse",t.color).forEach(a=>n.addChild(a))):s.addProperty(`color3f inputs:diffuseColor = ${w(t.color)}`),t.emissiveMap!==null){s.addProperty(`color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`);const i=new v(t.emissive.r*t.emissiveIntensity,t.emissive.g*t.emissiveIntensity,t.emissive.b*t.emissiveIntensity);o(t.emissiveMap,"emissive",i).forEach(d=>n.addChild(d))}else t.emissive.getHex()>0&&s.addProperty(`color3f inputs:emissiveColor = ${w(t.emissive)}`);if(t.normalMap!==null&&(s.addProperty(`normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),o(t.normalMap,"normal").forEach(a=>n.addChild(a))),t.aoMap!==null){s.addProperty(`float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`);const i=new v(t.aoMapIntensity,t.aoMapIntensity,t.aoMapIntensity);o(t.aoMap,"occlusion",i).forEach(d=>n.addChild(d))}if(t.roughnessMap!==null){s.addProperty(`float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`);const i=new v(t.roughness,t.roughness,t.roughness);o(t.roughnessMap,"roughness",i).forEach(d=>n.addChild(d))}else s.addProperty(`float inputs:roughness = ${t.roughness}`);if(t.metalnessMap!==null){s.addProperty(`float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`);const i=new v(t.metalness,t.metalness,t.metalness);o(t.metalnessMap,"metallic",i).forEach(d=>n.addChild(d))}else s.addProperty(`float inputs:metallic = ${t.metalness}`);if(t.alphaMap!==null?(s.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),s.addProperty("float inputs:opacityThreshold = 0.0001"),o(t.alphaMap,"opacity").forEach(a=>n.addChild(a))):s.addProperty(`float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial){if(t.clearcoatMap!==null){s.addProperty(`float inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`);const i=new v(t.clearcoat,t.clearcoat,t.clearcoat);o(t.clearcoatMap,"clearcoat",i).forEach(d=>n.addChild(d))}else s.addProperty(`float inputs:clearcoat = ${t.clearcoat}`);if(t.clearcoatRoughnessMap!==null){s.addProperty(`float inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);const i=new v(t.clearcoatRoughness,t.clearcoatRoughness,t.clearcoatRoughness);o(t.clearcoatRoughnessMap,"clearcoatRoughness",i).forEach(d=>n.addChild(d))}else s.addProperty(`float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`);s.addProperty(`float inputs:ior = ${t.ior}`)}return s.addProperty("int inputs:useSpecularWorkflow = 0"),s.addProperty("token outputs:surface"),n.addChild(s),n.addProperty(`token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>`),n}function w(t){return`(${t.r}, ${t.g}, ${t.b})`}function F(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function b(t){return`(${t.x}, ${t.y})`}function j(t,r){const e=N(t,r),n=O(t.matrix);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const o=new $(e,"Camera");o.addProperty(`matrix4d xformOp:transform = ${n}`),o.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]');const s=t.isOrthographicCamera?"orthographic":"perspective";o.addProperty(`token projection = "${s}"`);const i=`(${t.near.toPrecision(u)}, ${t.far.toPrecision(u)})`;o.addProperty(`float2 clippingRange = ${i}`);let a;t.isOrthographicCamera?a=((Math.abs(t.left)+Math.abs(t.right))*10).toPrecision(u):a=t.getFilmWidth().toPrecision(u),o.addProperty(`float horizontalAperture = ${a}`);let d;if(t.isOrthographicCamera?d=((Math.abs(t.top)+Math.abs(t.bottom))*10).toPrecision(u):d=t.getFilmHeight().toPrecision(u),o.addProperty(`float verticalAperture = ${d}`),t.isPerspectiveCamera){const l=t.getFocalLength().toPrecision(u);o.addProperty(`float focalLength = ${l}`);const c=t.focus.toPrecision(u);o.addProperty(`float focusDistance = ${c}`)}return o}export{J as USDZExporter};
