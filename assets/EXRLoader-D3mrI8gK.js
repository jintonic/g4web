import"./three-module-JdtKHQRM.js";import{a as ee}from"./three-editor-WSCnGzlb.js";import{D as yn,bt as ne,bw as K,bH as J,a8 as X,bT as te,bQ as ae,$ as xe,ej as Me}from"./three-core-CfGtZoax.js";class Pn extends yn{constructor(k){super(k),this.type=ne,this.outputFormat=K}parse(k){const de=Math.pow(2.7182818,2.2);function ke(e,n){let t=0;for(let l=0;l<65536;++l)(l==0||e[l>>3]&1<<(l&7))&&(n[t++]=l);const r=t-1;for(;t<65536;)n[t++]=0;return r}function De(e){for(let n=0;n<16384;n++)e[n]={},e[n].len=0,e[n].lit=0,e[n].p=null}const F={l:0,c:0,lc:0};function fe(e,n,t,r,l){for(;t<e;)n=n<<8|be(r,l),t+=8;t-=e,F.l=n>>t&(1<<e)-1,F.c=n,F.lc=t}const $=new Array(59);function Fe(e){for(let t=0;t<=58;++t)$[t]=0;for(let t=0;t<65537;++t)$[e[t]]+=1;let n=0;for(let t=58;t>0;--t){const r=n+$[t]>>1;$[t]=n,n=r}for(let t=0;t<65537;++t){const r=e[t];r>0&&(e[t]=r|$[r]++<<6)}}function Le(e,n,t,r,l,u){const o=n;let a=0,c=0;for(;r<=l;r++){if(o.value-n.value>t)return!1;fe(6,a,c,e,o);const s=F.l;if(a=F.c,c=F.lc,u[r]=s,s==63){if(o.value-n.value>t)throw new Error("Something wrong with hufUnpackEncTable");fe(8,a,c,e,o);let i=F.l+6;if(a=F.c,c=F.lc,r+i>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;i--;)u[r++]=0;r--}else if(s>=59){let i=s-59+2;if(r+i>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;i--;)u[r++]=0;r--}}Fe(u)}function we(e){return e&63}function Se(e){return e>>6}function Ze(e,n,t,r){for(;n<=t;n++){const l=Se(e[n]),u=we(e[n]);if(l>>u)throw new Error("Invalid table entry");if(u>14){const o=r[l>>u-14];if(o.len)throw new Error("Invalid table entry");if(o.lit++,o.p){const a=o.p;o.p=new Array(o.lit);for(let c=0;c<o.lit-1;++c)o.p[c]=a[c]}else o.p=new Array(1);o.p[o.lit-1]=n}else if(u){let o=0;for(let a=1<<14-u;a>0;a--){const c=r[(l<<14-u)+o];if(c.len||c.p)throw new Error("Invalid table entry");c.len=u,c.lit=n,o++}}}return!0}const Z={c:0,lc:0};function le(e,n,t,r){e=e<<8|be(t,r),n+=8,Z.c=e,Z.lc=n}const B={c:0,lc:0};function se(e,n,t,r,l,u,o,a,c){if(e==n){r<8&&(le(t,r,l,u),t=Z.c,r=Z.lc),r-=8;let s=t>>r;if(s=new Uint8Array([s])[0],a.value+s>c)return!1;const i=o[a.value-1];for(;s-- >0;)o[a.value++]=i}else if(a.value<c)o[a.value++]=e;else return!1;B.c=t,B.lc=r}function ce(e){return e&65535}function me(e){const n=ce(e);return n>32767?n-65536:n}const A={a:0,b:0};function G(e,n){const t=me(e),l=me(n),u=t+(l&1)+(l>>1),o=u,a=u-l;A.a=o,A.b=a}function W(e,n){const t=ce(e),r=ce(n),l=t-(r>>1)&65535,u=r+l-32768&65535;A.a=u,A.b=l}function Be(e,n,t,r,l,u,o){const a=o<16384,c=t>l?l:t;let s=1,i,p;for(;s<=c;)s<<=1;for(s>>=1,i=s,s>>=1;s>=1;){p=0;const h=p+u*(l-i),f=u*s,m=u*i,E=r*s,S=r*i;let y,C,v,T;for(;p<=h;p+=m){let _=p;const I=p+r*(t-i);for(;_<=I;_+=S){const b=_+E,O=_+f,N=O+E;a?(G(e[_+n],e[O+n]),y=A.a,v=A.b,G(e[b+n],e[N+n]),C=A.a,T=A.b,G(y,C),e[_+n]=A.a,e[b+n]=A.b,G(v,T),e[O+n]=A.a,e[N+n]=A.b):(W(e[_+n],e[O+n]),y=A.a,v=A.b,W(e[b+n],e[N+n]),C=A.a,T=A.b,W(y,C),e[_+n]=A.a,e[b+n]=A.b,W(v,T),e[O+n]=A.a,e[N+n]=A.b)}if(t&s){const b=_+f;a?G(e[_+n],e[b+n]):W(e[_+n],e[b+n]),y=A.a,e[b+n]=A.b,e[_+n]=y}}if(l&s){let _=p;const I=p+r*(t-i);for(;_<=I;_+=S){const b=_+E;a?G(e[_+n],e[b+n]):W(e[_+n],e[b+n]),y=A.a,e[b+n]=A.b,e[_+n]=y}}i=s,s>>=1}return p}function Pe(e,n,t,r,l,u,o,a,c){let s=0,i=0;const p=o,h=Math.trunc(r.value+(l+7)/8);for(;r.value<h;)for(le(s,i,t,r),s=Z.c,i=Z.lc;i>=14;){const m=s>>i-14&16383,E=n[m];if(E.len)i-=E.len,se(E.lit,u,s,i,t,r,a,c,p),s=B.c,i=B.lc;else{if(!E.p)throw new Error("hufDecode issues");let S;for(S=0;S<E.lit;S++){const y=we(e[E.p[S]]);for(;i<y&&r.value<h;)le(s,i,t,r),s=Z.c,i=Z.lc;if(i>=y&&Se(e[E.p[S]])==(s>>i-y&(1<<y)-1)){i-=y,se(E.p[S],u,s,i,t,r,a,c,p),s=B.c,i=B.lc;break}}if(S==E.lit)throw new Error("hufDecode issues")}}const f=8-l&7;for(s>>=f,i-=f;i>0;){const m=n[s<<14-i&16383];if(m.len)i-=m.len,se(m.lit,u,s,i,t,r,a,c,p),s=B.c,i=B.lc;else throw new Error("hufDecode issues")}return!0}function ye(e,n,t,r,l,u){const o={value:0},a=t.value,c=d(n,t),s=d(n,t);t.value+=4;const i=d(n,t);if(t.value+=4,c<0||c>=65537||s<0||s>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const p=new Array(65537),h=new Array(16384);De(h);const f=r-(t.value-a);if(Le(e,t,f,c,s,p),i>8*(r-(t.value-a)))throw new Error("Something wrong with hufUncompress");Ze(p,c,s,h),Pe(p,h,e,t,i,s,u,l,o)}function He(e,n,t){for(let r=0;r<t;++r)n[r]=e[n[r]]}function Ie(e){for(let n=1;n<e.length;n++){const t=e[n-1]+e[n]-128;e[n]=t}}function ge(e,n){let t=0,r=Math.floor((e.length+1)/2),l=0;const u=e.length-1;for(;!(l>u||(n[l++]=e[t++],l>u));)n[l++]=e[r++]}function Ce(e){let n=e.byteLength;const t=new Array;let r=0;const l=new DataView(e);for(;n>0;){const u=l.getInt8(r++);if(u<0){const o=-u;n-=o+1;for(let a=0;a<o;a++)t.push(l.getUint8(r++))}else{const o=u;n-=2;const a=l.getUint8(r++);for(let c=0;c<o+1;c++)t.push(a)}}return t}function ze(e,n,t,r,l,u){let o=new DataView(u.buffer);const a=t[e.idx[0]].width,c=t[e.idx[0]].height,s=3,i=Math.floor(a/8),p=Math.ceil(a/8),h=Math.ceil(c/8),f=a-(p-1)*8,m=c-(h-1)*8,E={value:0},S=new Array(s),y=new Array(s),C=new Array(s),v=new Array(s),T=new Array(s);for(let I=0;I<s;++I)T[I]=n[e.idx[I]],S[I]=I<1?0:S[I-1]+p*h,y[I]=new Float32Array(64),C[I]=new Uint16Array(64),v[I]=new Uint16Array(p*64);for(let I=0;I<h;++I){let b=8;I==h-1&&(b=m);let O=8;for(let g=0;g<p;++g){g==p-1&&(O=f);for(let U=0;U<s;++U)C[U].fill(0),C[U][0]=l[S[U]++],_e(E,r,C[U]),ve(C[U],y[U]),Ue(y[U]);Xe(y);for(let U=0;U<s;++U)Ne(y[U],v[U],g*64)}let N=0;for(let g=0;g<s;++g){const U=t[e.idx[g]].type;for(let L=8*I;L<8*I+b;++L){N=T[g][L];for(let Q=0;Q<i;++Q){const D=Q*64+(L&7)*8;o.setUint16(N+0*U,v[g][D+0],!0),o.setUint16(N+2*U,v[g][D+1],!0),o.setUint16(N+4*U,v[g][D+2],!0),o.setUint16(N+6*U,v[g][D+3],!0),o.setUint16(N+8*U,v[g][D+4],!0),o.setUint16(N+10*U,v[g][D+5],!0),o.setUint16(N+12*U,v[g][D+6],!0),o.setUint16(N+14*U,v[g][D+7],!0),N+=16*U}}if(i!=p)for(let L=8*I;L<8*I+b;++L){const Q=T[g][L]+8*i*2*U,D=i*64+(L&7)*8;for(let j=0;j<O;++j)o.setUint16(Q+j*2*U,v[g][D+j],!0)}}}const _=new Uint16Array(a);o=new DataView(u.buffer);for(let I=0;I<s;++I){t[e.idx[I]].decoded=!0;const b=t[e.idx[I]].type;if(t[I].type==2)for(let O=0;O<c;++O){const N=T[I][O];for(let g=0;g<a;++g)_[g]=o.getUint16(N+g*2*b,!0);for(let g=0;g<a;++g)o.setFloat32(N+g*2*b,w(_[g]),!0)}}}function Ye(e,n,t,r,l,u){const o=new DataView(u.buffer),a=t[e],c=a.width,s=a.height,i=Math.ceil(c/8),p=Math.ceil(s/8),h=Math.floor(c/8),f=c-(i-1)*8,m=s-(p-1)*8,E={value:0};let S=0;const y=new Float32Array(64),C=new Uint16Array(64),v=new Uint16Array(i*64);for(let T=0;T<p;++T){let _=8;T==p-1&&(_=m);for(let I=0;I<i;++I)C.fill(0),C[0]=l[S++],_e(E,r,C),ve(C,y),Ue(y),Ne(y,v,I*64);for(let I=8*T;I<8*T+_;++I){let b=n[e][I];for(let O=0;O<h;++O){const N=O*64+(I&7)*8;for(let g=0;g<8;++g)o.setUint16(b+g*2*a.type,v[N+g],!0);b+=16*a.type}if(i!=h){const O=h*64+(I&7)*8;for(let N=0;N<f;++N)o.setUint16(b+N*2*a.type,v[O+N],!0)}}}a.decoded=!0}function _e(e,n,t){let r,l=1;for(;l<64;)r=n[e.value],r==65280?l=64:r>>8==255?l+=r&255:(t[l]=r,l++),e.value++}function ve(e,n){n[0]=w(e[0]),n[1]=w(e[1]),n[2]=w(e[5]),n[3]=w(e[6]),n[4]=w(e[14]),n[5]=w(e[15]),n[6]=w(e[27]),n[7]=w(e[28]),n[8]=w(e[2]),n[9]=w(e[4]),n[10]=w(e[7]),n[11]=w(e[13]),n[12]=w(e[16]),n[13]=w(e[26]),n[14]=w(e[29]),n[15]=w(e[42]),n[16]=w(e[3]),n[17]=w(e[8]),n[18]=w(e[12]),n[19]=w(e[17]),n[20]=w(e[25]),n[21]=w(e[30]),n[22]=w(e[41]),n[23]=w(e[43]),n[24]=w(e[9]),n[25]=w(e[11]),n[26]=w(e[18]),n[27]=w(e[24]),n[28]=w(e[31]),n[29]=w(e[40]),n[30]=w(e[44]),n[31]=w(e[53]),n[32]=w(e[10]),n[33]=w(e[19]),n[34]=w(e[23]),n[35]=w(e[32]),n[36]=w(e[39]),n[37]=w(e[45]),n[38]=w(e[52]),n[39]=w(e[54]),n[40]=w(e[20]),n[41]=w(e[22]),n[42]=w(e[33]),n[43]=w(e[38]),n[44]=w(e[46]),n[45]=w(e[51]),n[46]=w(e[55]),n[47]=w(e[60]),n[48]=w(e[21]),n[49]=w(e[34]),n[50]=w(e[37]),n[51]=w(e[47]),n[52]=w(e[50]),n[53]=w(e[56]),n[54]=w(e[59]),n[55]=w(e[61]),n[56]=w(e[35]),n[57]=w(e[36]),n[58]=w(e[48]),n[59]=w(e[49]),n[60]=w(e[57]),n[61]=w(e[58]),n[62]=w(e[62]),n[63]=w(e[63])}function Ue(e){const n=.5*Math.cos(.7853975),t=.5*Math.cos(3.14159/16),r=.5*Math.cos(3.14159/8),l=.5*Math.cos(3*3.14159/16),u=.5*Math.cos(5*3.14159/16),o=.5*Math.cos(3*3.14159/8),a=.5*Math.cos(7*3.14159/16),c=new Array(4),s=new Array(4),i=new Array(4),p=new Array(4);for(let h=0;h<8;++h){const f=h*8;c[0]=r*e[f+2],c[1]=o*e[f+2],c[2]=r*e[f+6],c[3]=o*e[f+6],s[0]=t*e[f+1]+l*e[f+3]+u*e[f+5]+a*e[f+7],s[1]=l*e[f+1]-a*e[f+3]-t*e[f+5]-u*e[f+7],s[2]=u*e[f+1]-t*e[f+3]+a*e[f+5]+l*e[f+7],s[3]=a*e[f+1]-u*e[f+3]+l*e[f+5]-t*e[f+7],i[0]=n*(e[f+0]+e[f+4]),i[3]=n*(e[f+0]-e[f+4]),i[1]=c[0]+c[3],i[2]=c[1]-c[2],p[0]=i[0]+i[1],p[1]=i[3]+i[2],p[2]=i[3]-i[2],p[3]=i[0]-i[1],e[f+0]=p[0]+s[0],e[f+1]=p[1]+s[1],e[f+2]=p[2]+s[2],e[f+3]=p[3]+s[3],e[f+4]=p[3]-s[3],e[f+5]=p[2]-s[2],e[f+6]=p[1]-s[1],e[f+7]=p[0]-s[0]}for(let h=0;h<8;++h)c[0]=r*e[16+h],c[1]=o*e[16+h],c[2]=r*e[48+h],c[3]=o*e[48+h],s[0]=t*e[8+h]+l*e[24+h]+u*e[40+h]+a*e[56+h],s[1]=l*e[8+h]-a*e[24+h]-t*e[40+h]-u*e[56+h],s[2]=u*e[8+h]-t*e[24+h]+a*e[40+h]+l*e[56+h],s[3]=a*e[8+h]-u*e[24+h]+l*e[40+h]-t*e[56+h],i[0]=n*(e[h]+e[32+h]),i[3]=n*(e[h]-e[32+h]),i[1]=c[0]+c[3],i[2]=c[1]-c[2],p[0]=i[0]+i[1],p[1]=i[3]+i[2],p[2]=i[3]-i[2],p[3]=i[0]-i[1],e[0+h]=p[0]+s[0],e[8+h]=p[1]+s[1],e[16+h]=p[2]+s[2],e[24+h]=p[3]+s[3],e[32+h]=p[3]-s[3],e[40+h]=p[2]-s[2],e[48+h]=p[1]-s[1],e[56+h]=p[0]-s[0]}function Xe(e){for(let n=0;n<64;++n){const t=e[0][n],r=e[1][n],l=e[2][n];e[0][n]=t+1.5747*l,e[1][n]=t-.1873*r-.4682*l,e[2][n]=t+1.8556*r}}function Ne(e,n,t){for(let r=0;r<64;++r)n[t+r]=Me.toHalfFloat(Ge(e[r]))}function Ge(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(de,Math.abs(e)-1)}function ie(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function We(e){const n=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),t=new Uint8Array(Ce(n)),r=new Uint8Array(t.length);return Ie(t),ge(t,r),new DataView(r.buffer)}function ue(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=ee(n),r=new Uint8Array(t.length);return Ie(t),ge(t,r),new DataView(r.buffer)}function Ke(e){const n=e.viewer,t={value:e.offset.value},r=new Uint16Array(e.columns*e.lines*(e.inputChannels.length*e.type)),l=new Uint8Array(8192);let u=0;const o=new Array(e.inputChannels.length);for(let m=0,E=e.inputChannels.length;m<E;m++)o[m]={},o[m].start=u,o[m].end=o[m].start,o[m].nx=e.columns,o[m].ny=e.lines,o[m].size=e.type,u+=o[m].nx*o[m].ny*o[m].size;const a=q(n,t),c=q(n,t);if(c>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(a<=c)for(let m=0;m<c-a+1;m++)l[m+a]=P(n,t);const s=new Uint16Array(65536),i=ke(l,s),p=d(n,t);ye(e.array,n,t,p,r,u);for(let m=0;m<e.inputChannels.length;++m){const E=o[m];for(let S=0;S<o[m].size;++S)Be(r,E.start+S,E.nx,E.size,E.ny,E.nx*E.size,i)}He(s,r,u);let h=0;const f=new Uint8Array(r.buffer.byteLength);for(let m=0;m<e.lines;m++)for(let E=0;E<e.inputChannels.length;E++){const S=o[E],y=S.nx*S.size,C=new Uint8Array(r.buffer,S.end*2,y*2);f.set(C,h),h+=y*2,S.end+=y}return new DataView(f.buffer)}function $e(e){const n=e.array.slice(e.offset.value,e.offset.value+e.size),t=ee(n),r=e.inputChannels.length*e.lines*e.columns*e.totalBytes,l=new ArrayBuffer(r),u=new DataView(l);let o=0,a=0;const c=new Array(4);for(let s=0;s<e.lines;s++)for(let i=0;i<e.inputChannels.length;i++){let p=0;switch(e.inputChannels[i].pixelType){case 1:c[0]=o,c[1]=c[0]+e.columns,o=c[1]+e.columns;for(let f=0;f<e.columns;++f){const m=t[c[0]++]<<8|t[c[1]++];p+=m,u.setUint16(a,p,!0),a+=2}break;case 2:c[0]=o,c[1]=c[0]+e.columns,c[2]=c[1]+e.columns,o=c[2]+e.columns;for(let f=0;f<e.columns;++f){const m=t[c[0]++]<<24|t[c[1]++]<<16|t[c[2]++]<<8;p+=m,u.setUint32(a,p,!0),a+=4}break}}return u}function Ae(e){const n=e.viewer,t={value:e.offset.value},r=new Uint8Array(e.columns*e.lines*(e.inputChannels.length*e.type*2)),l={version:x(n,t),unknownUncompressedSize:x(n,t),unknownCompressedSize:x(n,t),acCompressedSize:x(n,t),dcCompressedSize:x(n,t),rleCompressedSize:x(n,t),rleUncompressedSize:x(n,t),rleRawSize:x(n,t),totalAcUncompressedCount:x(n,t),totalDcUncompressedCount:x(n,t),acCompression:x(n,t)};if(l.version<2)throw new Error("EXRLoader.parse: "+Y.compression+" version "+l.version+" is unsupported");const u=new Array;let o=q(n,t)-2;for(;o>0;){const E=V(n.buffer,t),S=P(n,t),y=S>>2&3,C=(S>>4)-1,v=new Int8Array([C])[0],T=P(n,t);u.push({name:E,index:v,type:T,compression:y}),o-=E.length+3}const a=Y.channels,c=new Array(e.inputChannels.length);for(let E=0;E<e.inputChannels.length;++E){const S=c[E]={},y=a[E];S.name=y.name,S.compression=0,S.decoded=!1,S.type=y.pixelType,S.pLinear=y.pLinear,S.width=e.columns,S.height=e.lines}const s={idx:new Array(3)};for(let E=0;E<e.inputChannels.length;++E){const S=c[E];for(let y=0;y<u.length;++y){const C=u[y];S.name==C.name&&(S.compression=C.compression,C.index>=0&&(s.idx[C.index]=E),S.offset=E)}}let i,p,h;if(l.acCompressedSize>0)switch(l.acCompression){case 0:i=new Uint16Array(l.totalAcUncompressedCount),ye(e.array,n,t,l.acCompressedSize,i,l.totalAcUncompressedCount);break;case 1:const E=e.array.slice(t.value,t.value+l.totalAcUncompressedCount),S=ee(E);i=new Uint16Array(S.buffer),t.value+=l.totalAcUncompressedCount;break}if(l.dcCompressedSize>0){const E={array:e.array,offset:t,size:l.dcCompressedSize};p=new Uint16Array(ue(E).buffer),t.value+=l.dcCompressedSize}if(l.rleRawSize>0){const E=e.array.slice(t.value,t.value+l.rleCompressedSize),S=ee(E);h=Ce(S.buffer),t.value+=l.rleCompressedSize}let f=0;const m=new Array(c.length);for(let E=0;E<m.length;++E)m[E]=new Array;for(let E=0;E<e.lines;++E)for(let S=0;S<c.length;++S)m[S].push(f),f+=c[S].width*e.type*2;s.idx[0]!==void 0&&c[s.idx[0]]&&ze(s,m,c,i,p,r);for(let E=0;E<c.length;++E){const S=c[E];if(!S.decoded)switch(S.compression){case 2:let y=0,C=0;for(let v=0;v<e.lines;++v){let T=m[E][y];for(let _=0;_<S.width;++_){for(let I=0;I<2*S.type;++I)r[T++]=h[C+I*S.width*S.height];C++}y++}break;case 1:Ye(E,m,c,i,p,r);break;default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(r.buffer)}function V(e,n){const t=new Uint8Array(e);let r=0;for(;t[n.value+r]!=0;)r+=1;const l=new TextDecoder().decode(t.slice(n.value,n.value+r));return n.value=n.value+r+1,l}function qe(e,n,t){const r=new TextDecoder().decode(new Uint8Array(e).slice(n.value,n.value+t));return n.value=n.value+t,r}function Qe(e,n){const t=M(e,n),r=d(e,n);return[t,r]}function Je(e,n){const t=d(e,n),r=d(e,n);return[t,r]}function M(e,n){const t=e.getInt32(n.value,!0);return n.value=n.value+4,t}function d(e,n){const t=e.getUint32(n.value,!0);return n.value=n.value+4,t}function be(e,n){const t=e[n.value];return n.value=n.value+1,t}function P(e,n){const t=e.getUint8(n.value);return n.value=n.value+1,t}const x=function(e,n){let t;return"getBigInt64"in DataView.prototype?t=Number(e.getBigInt64(n.value,!0)):t=e.getUint32(n.value+4,!0)+Number(e.getUint32(n.value,!0)<<32),n.value+=8,t};function R(e,n){const t=e.getFloat32(n.value,!0);return n.value+=4,t}function Ve(e,n){return Me.toHalfFloat(R(e,n))}function w(e){const n=(e&31744)>>10,t=e&1023;return(e>>15?-1:1)*(n?n===31?t?NaN:1/0:Math.pow(2,n-15)*(1+t/1024):6103515625e-14*(t/1024))}function q(e,n){const t=e.getUint16(n.value,!0);return n.value+=2,t}function je(e,n){return w(q(e,n))}function en(e,n,t,r){const l=t.value,u=[];for(;t.value<l+r-1;){const o=V(n,t),a=M(e,t),c=P(e,t);t.value+=3;const s=M(e,t),i=M(e,t);u.push({name:o,pixelType:a,pLinear:c,xSampling:s,ySampling:i})}return t.value+=1,u}function nn(e,n){const t=R(e,n),r=R(e,n),l=R(e,n),u=R(e,n),o=R(e,n),a=R(e,n),c=R(e,n),s=R(e,n);return{redX:t,redY:r,greenX:l,greenY:u,blueX:o,blueY:a,whiteX:c,whiteY:s}}function tn(e,n){const t=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],r=P(e,n);return t[r]}function on(e,n){const t=M(e,n),r=M(e,n),l=M(e,n),u=M(e,n);return{xMin:t,yMin:r,xMax:l,yMax:u}}function rn(e,n){const t=["INCREASING_Y","DECREASING_Y","RANDOM_Y"],r=P(e,n);return t[r]}function ln(e,n){const t=["ENVMAP_LATLONG","ENVMAP_CUBE"],r=P(e,n);return t[r]}function sn(e,n){const t=["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"],r=["ROUND_DOWN","ROUND_UP"],l=d(e,n),u=d(e,n),o=P(e,n);return{xSize:l,ySize:u,levelMode:t[o&15],roundingMode:r[o>>4]}}function cn(e,n){const t=R(e,n),r=R(e,n);return[t,r]}function un(e,n){const t=R(e,n),r=R(e,n),l=R(e,n);return[t,r,l]}function an(e,n,t,r,l){if(r==="string"||r==="stringvector"||r==="iccProfile")return qe(n,t,l);if(r==="chlist")return en(e,n,t,l);if(r==="chromaticities")return nn(e,t);if(r==="compression")return tn(e,t);if(r==="box2i")return on(e,t);if(r==="envmap")return ln(e,t);if(r==="tiledesc")return sn(e,t);if(r==="lineOrder")return rn(e,t);if(r==="float")return R(e,t);if(r==="v2f")return cn(e,t);if(r==="v3f")return un(e,t);if(r==="int")return M(e,t);if(r==="rational")return Qe(e,t);if(r==="timecode")return Je(e,t);if(r==="preview")return t.value+=l,"skipped";t.value+=l}function hn(e,n){const t=Math.log2(e);return n=="ROUND_DOWN"?Math.floor(t):Math.ceil(t)}function pn(e,n,t){let r=0;switch(e.levelMode){case"ONE_LEVEL":r=1;break;case"MIPMAP_LEVELS":r=hn(Math.max(n,t),e.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return r}function Te(e,n,t,r){const l=new Array(e);for(let u=0;u<e;u++){const o=1<<u;let a=n/o|0;r=="ROUND_UP"&&a*o<n&&(a+=1);const c=Math.max(a,1);l[u]=(c+t-1)/t|0}return l}function En(){const e=this,n=e.offset,t={value:0};for(let r=0;r<e.tileCount;r++){const l=M(e.viewer,n),u=M(e.viewer,n);n.value+=8,e.size=d(e.viewer,n);const o=l*e.blockWidth,a=u*e.blockHeight;e.columns=o+e.blockWidth>e.width?e.width-o:e.blockWidth,e.lines=a+e.blockHeight>e.height?e.height-a:e.blockHeight;const c=e.columns*e.totalBytes,i=e.size<e.lines*c?e.uncompress(e):ie(e);n.value+=e.size;for(let p=0;p<e.lines;p++){const h=p*e.columns*e.totalBytes;for(let f=0;f<e.inputChannels.length;f++){const m=Y.channels[f].name,E=e.channelByteOffsets[m]*e.columns,S=e.decodeChannels[m];if(S===void 0)continue;t.value=h+E;const y=(e.height-(1+a+p))*e.outLineWidth;for(let C=0;C<e.columns;C++){const v=y+(C+o)*e.outputChannels+S;e.byteArray[v]=e.getter(i,t)}}}}}function fn(){const e=this,n=e.offset,t={value:0};for(let r=0;r<e.height/e.blockHeight;r++){const l=M(e.viewer,n)-Y.dataWindow.yMin;e.size=d(e.viewer,n),e.lines=l+e.blockHeight>e.height?e.height-l:e.blockHeight;const u=e.columns*e.totalBytes,a=e.size<e.lines*u?e.uncompress(e):ie(e);n.value+=e.size;for(let c=0;c<e.blockHeight;c++){const s=r*e.blockHeight,i=c+e.scanOrder(s);if(i>=e.height)continue;const p=c*u,h=(e.height-1-i)*e.outLineWidth;for(let f=0;f<e.inputChannels.length;f++){const m=Y.channels[f].name,E=e.channelByteOffsets[m]*e.columns,S=e.decodeChannels[m];if(S!==void 0){t.value=p+E;for(let y=0;y<e.columns;y++){const C=h+y*e.outputChannels+S;e.byteArray[C]=e.getter(a,t)}}}}}}function wn(e,n,t){const r={};if(e.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");r.version=e.getUint8(4);const l=e.getUint8(5);r.spec={singleTile:!!(l&2),longName:!!(l&4),deepFormat:!!(l&8),multiPart:!!(l&16)},t.value=8;let u=!0;for(;u;){const o=V(n,t);if(o==="")u=!1;else{const a=V(n,t),c=d(e,t),s=an(e,n,t,a,c);s===void 0?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${a}'.`):r[o]=s}}if((l&-7)!=0)throw console.error("THREE.EXRHeader:",r),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return r}function Sn(e,n,t,r,l,u){const o={size:0,viewer:n,array:t,offset:r,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,inputChannels:e.channels,channelByteOffsets:{},shouldExpand:!1,scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:X};switch(e.compression){case"NO_COMPRESSION":o.blockHeight=1,o.uncompress=ie;break;case"RLE_COMPRESSION":o.blockHeight=1,o.uncompress=We;break;case"ZIPS_COMPRESSION":o.blockHeight=1,o.uncompress=ue;break;case"ZIP_COMPRESSION":o.blockHeight=16,o.uncompress=ue;break;case"PIZ_COMPRESSION":o.blockHeight=32,o.uncompress=Ke;break;case"PXR24_COMPRESSION":o.blockHeight=16,o.uncompress=$e;break;case"DWAA_COMPRESSION":o.blockHeight=32,o.uncompress=Ae;break;case"DWAB_COMPRESSION":o.blockHeight=256,o.uncompress=Ae;break;default:throw new Error("EXRLoader.parse: "+e.compression+" is unsupported")}const a={};for(const h of e.channels)switch(h.name){case"Y":case"R":case"G":case"B":case"A":a[h.name]=!0,o.type=h.pixelType}let c=!1,s=!1;if(a.R&&a.G&&a.B)o.outputChannels=4;else if(a.Y)o.outputChannels=1;else throw new Error("EXRLoader.parse: file contains unsupported data channels.");switch(o.outputChannels){case 4:u==K?(c=!a.A,o.format=K,o.colorSpace=X,o.outputChannels=4,o.decodeChannels={R:0,G:1,B:2,A:3}):u==J?(o.format=J,o.colorSpace=X,o.outputChannels=2,o.decodeChannels={R:0,G:1}):u==te?(o.format=te,o.colorSpace=X,o.outputChannels=1,o.decodeChannels={R:0}):s=!0;break;case 1:u==K?(c=!0,o.format=K,o.colorSpace=X,o.outputChannels=4,o.shouldExpand=!0,o.decodeChannels={Y:0}):u==J?(o.format=J,o.colorSpace=X,o.outputChannels=2,o.shouldExpand=!0,o.decodeChannels={Y:0}):u==te?(o.format=te,o.colorSpace=X,o.outputChannels=1,o.decodeChannels={Y:0}):s=!0;break;default:s=!0}if(s)throw new Error("EXRLoader.parse: invalid output format for specified file.");if(o.type==1)switch(l){case ae:o.getter=je;break;case ne:o.getter=q;break}else if(o.type==2)switch(l){case ae:o.getter=R;break;case ne:o.getter=Ve}else throw new Error("EXRLoader.parse: unsupported pixelType "+o.type+" for "+e.compression+".");o.columns=o.width;const i=o.width*o.height*o.outputChannels;switch(l){case ae:o.byteArray=new Float32Array(i),c&&o.byteArray.fill(1,0,i);break;case ne:o.byteArray=new Uint16Array(i),c&&o.byteArray.fill(15360,0,i);break;default:console.error("THREE.EXRLoader: unsupported type: ",l);break}let p=0;for(const h of e.channels)o.decodeChannels[h.name]!==void 0&&(o.channelByteOffsets[h.name]=p),p+=h.pixelType*2;if(o.totalBytes=p,o.outLineWidth=o.width*o.outputChannels,e.lineOrder==="INCREASING_Y"?o.scanOrder=h=>h:o.scanOrder=h=>o.height-1-h,e.spec.singleTile){o.blockHeight=e.tiles.ySize,o.blockWidth=e.tiles.xSize;const h=pn(e.tiles,o.width,o.height),f=Te(h,o.width,e.tiles.xSize,e.tiles.roundingMode),m=Te(h,o.height,e.tiles.ySize,e.tiles.roundingMode);o.tileCount=f[0]*m[0];for(let E=0;E<h;E++)for(let S=0;S<m[E];S++)for(let y=0;y<f[E];y++)x(n,r);o.decode=En.bind(o)}else{o.blockWidth=o.width;const h=Math.ceil(o.height/o.blockHeight);for(let f=0;f<h;f++)x(n,r);o.decode=fn.bind(o)}return o}const Oe={value:0},Re=new DataView(k),mn=new Uint8Array(k),Y=wn(Re,k,Oe),H=Sn(Y,Re,mn,Oe,this.type,this.outputFormat);if(H.decode(),H.shouldExpand){const e=H.byteArray;if(this.outputFormat==K)for(let n=0;n<e.length;n+=4)e[n+2]=e[n+1]=e[n];else if(this.outputFormat==J)for(let n=0;n<e.length;n+=2)e[n+1]=e[n]}return{header:Y,width:H.width,height:H.height,data:H.byteArray,format:H.format,colorSpace:H.colorSpace,type:this.type}}setDataType(k){return this.type=k,this}setOutputFormat(k){return this.outputFormat=k,this}load(k,oe,he,pe){function Ee(z,re){z.colorSpace=re.colorSpace,z.minFilter=xe,z.magFilter=xe,z.generateMipmaps=!1,z.flipY=!1,oe&&oe(z,re)}return super.load(k,Ee,he,pe)}}export{Pn as EXRLoader};
