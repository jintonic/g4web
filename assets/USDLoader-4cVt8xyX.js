import{G as pt,c as Z,a5 as mt,a7 as lt,H as N,O as ht,_ as It,l as vt,q as gt,t as W,a3 as at,a4 as yt,a as ft,Q as At,R as Pt,v as kt,b as St,W as Ft,$ as Tt,a6 as _t,a9 as ct,a8 as K,s as H,ar as Q,L as Ut,F as bt,u as Bt}from"./main-z5BJ3CM8.js";const Mt=/^def\s+(?:(\w+)\s+)?"?([^"]+)"?$/,Ot=/^string\s+(\w+)$/,Vt=/^(?:uniform\s+)?(\w+(?:\[\])?)\s+(.+)$/;class Ct{parseText(t){t=this._preprocess(t);const e={},n=t.split(`
`);let s=null,i=e;const r=[e];for(const o of n)if(o.includes("=")){const l=this._findAssignmentOperator(o);if(l===-1){s=o.trim();continue}const f=o.slice(0,l).trim(),h=o.slice(l+1).trim();if(h.endsWith("{")){const c={};r.push(c),i[f]=c,i=c}else if(h.endsWith("(")){const c=h.slice(0,-1);i[f]=c;const u={};r.push(u),i=u}else i[f]=h}else if(o.includes(":")&&!o.includes("=")){const l=o.indexOf(":"),f=o.slice(0,l).trim(),h=o.slice(l+1).trim();/^[\d.]+$/.test(f)&&(i[f]=h)}else if(o.endsWith("{")){const l=i[s]||{};r.push(l),i[s]=l,i=l}else if(o.endsWith("}")){if(r.pop(),r.length===0)continue;i=r[r.length-1]}else if(o.endsWith("(")){const l={};r.push(l),s=o.split("(")[0].trim()||s,i[s]=l,i=l}else o.endsWith(")")?(r.pop(),i=r[r.length-1]):o.trim()&&(s=o.trim());return e}_preprocess(t){t=this._stripBlockComments(t),t=this._collapseTripleQuotedStrings(t);const e=t.split(`
`),n=[];let s=!1,i=0,r=0,o="";for(let l=0;l<e.length;l++){let f=e[l];f=this._stripInlineComment(f);const h=f.trim();if(s){o+=" "+h;for(const c of h)c==="["?i++:c==="]"?i--:c==="("&&i>0?r++:c===")"&&i>0&&r--;i===0&&r===0&&(n.push(o),o="",s=!1)}else{if(h.includes("=")){const c=this._findAssignmentOperator(h);if(c!==-1){const u=h.slice(c+1).trim();let a=0,p=0;for(const d of u)d==="["?a++:d==="]"&&p++;if(a>p){s=!0,i=a-p,r=0,o=h;continue}}}n.push(h)}}return n.join(`
`)}_stripBlockComments(t){let e="",n=0;for(;n<t.length;)if(t[n]==="/"&&n+1<t.length&&t[n+1]==="*"){let s=n+2;for(;s<t.length;){if(t[s]==="*"&&s+1<t.length&&t[s+1]==="/"){s+=2;break}s++}n=s}else e+=t[n],n++;return e}_collapseTripleQuotedStrings(t){let e="",n=0;for(;n<t.length;){if(n+2<t.length){const s=t.slice(n,n+3);if(s==="'''"||s==='"""'){const i=s;for(e+=i,n+=3;n<t.length;)if(n+2<t.length&&t.slice(n,n+3)===i){e+=i,n+=3;break}else t[n]===`
`?e+="\\n":t[n]!=="\r"&&(e+=t[n]),n++;continue}}e+=t[n],n++}return e}_stripInlineComment(t){if(t.trim().startsWith("#usda"))return t;let e=!1,n=null,s=!1;for(let i=0;i<t.length;i++){const r=t[i];if(s){s=!1;continue}if(r==="\\"){s=!0;continue}if(!e&&(r==='"'||r==="'"))e=!0,n=r;else if(e&&r===n)e=!1,n=null;else if(!e&&r==="#")return t.slice(0,i).trimEnd()}return t}_findAssignmentOperator(t){let e=!1,n=null,s=!1;for(let i=0;i<t.length;i++){const r=t[i];if(s){s=!1;continue}if(r==="\\"){s=!0;continue}if(!e&&(r==='"'||r==="'"))e=!0,n=r;else if(e&&r===n)e=!1,n=null;else if(!e&&r==="=")return i}return-1}parseData(t){const e=this.parseText(t),n={},s={Attribute:1,Prim:6,Relationship:8},i={};if("#usda 1.0"in e){const o=e["#usda 1.0"];o.upAxis&&(i.upAxis=o.upAxis.replace(/"/g,"")),o.defaultPrim&&(i.defaultPrim=o.defaultPrim.replace(/"/g,""))}n["/"]={specType:s.Prim,fields:i};const r=(o,l)=>{const f=[];for(const h in o){if(h==="#usda 1.0"||h==="variants")continue;const c=h.match(Mt);if(c){const u=c[1]||"",a=c[2],p=l==="/"?"/"+a:l+"/"+a;f.push(a);const d={typeName:u},m=o[h];this._extractPrimData(m,p,d,n,s),n[p]={specType:s.Prim,fields:d},r(m,p)}}f.length>0&&n[l]&&(n[l].fields.primChildren=f)};return r(e,"/"),{specsByPath:n}}_extractPrimData(t,e,n,s,i){if(!(!t||typeof t!="object"))for(const r in t){if(r.startsWith("def "))continue;if(r==="prepend references"){n.references=[t[r]];continue}if(r==="payload"){n.payload=t[r];continue}if(r==="variants"){const l={},f=t[r];for(const h in f){const c=h.match(Ot);if(c){const u=c[1],a=f[h].replace(/"/g,"");l[u]=a}}Object.keys(l).length>0&&(n.variantSelection=l);continue}if(r.startsWith("rel ")){const l=r.slice(4),f=e+"."+l,h=t[r].replace(/[<>]/g,"");s[f]={specType:i.Relationship,fields:{targetPaths:[h]}};continue}if(r.includes("xformOpOrder")){const l=t[r].replace(/[\[\]]/g,"").split(",").map(f=>f.trim().replace(/"/g,""));n.xformOpOrder=l;continue}const o=r.match(Vt);if(o){const l=o[1],f=o[2],h=t[r];if(f.endsWith(".connect")){const c=f.slice(0,-8),u=e+"."+c;let a=String(h).trim();a.startsWith("<")&&(a=a.slice(1)),a.endsWith(">")&&(a=a.slice(0,-1)),s[u]||(s[u]={specType:i.Attribute,fields:{typeName:l}}),s[u].fields.connectionPaths=[a];continue}if(f.endsWith(".timeSamples")&&typeof h=="object"){const c=f.slice(0,-12),u=e+"."+c,a=[],p=[];for(const m in h){const _=parseFloat(m);isNaN(_)||(a.push(_),p.push(this._parseAttributeValue(l,h[m])))}const d=a.map((m,_)=>({t:m,v:p[_]})).sort((m,_)=>m.t-_.t);s[u]={specType:i.Attribute,fields:{timeSamples:{times:d.map(m=>m.t),values:d.map(m=>m.v)},typeName:l}}}else{const c=this._parseAttributeValue(l,h),u=e+"."+f;s[u]={specType:i.Attribute,fields:{default:c,typeName:l}}}}}}_parseAttributeValue(t,e){if(e==null)return;const n=String(e).trim();if(t.endsWith("[]"))try{let s=n.replace(/\(/g,"[").replace(/\)/g,"]");s.endsWith(",")&&(s=s.slice(0,-1));const i=JSON.parse(s);return Array.isArray(i)&&Array.isArray(i[0])?i.flat():i}catch{return n.replace(/[\[\]]/g,"").split(",").map(r=>{const o=r.trim(),l=parseFloat(o);return isNaN(l)?o.replace(/"/g,""):l})}if(t.includes("3")||t.includes("2")||t.includes("4"))return n.replace(/[()]/g,"").split(",").map(r=>parseFloat(r.trim()));if(t.startsWith("quat")){const i=n.replace(/[()]/g,"").split(",").map(r=>parseFloat(r.trim()));return[i[1],i[2],i[3],i[0]]}return t.includes("matrix")?n.replace(/[()]/g,"").split(",").map(r=>parseFloat(r.trim())):t==="float"||t==="double"||t==="int"?parseFloat(n):t==="string"||t==="token"?this._parseString(n):t==="asset"?n.replace(/@/g,"").replace(/"/g,""):this._parseString(n)}_parseString(t){(t.startsWith('"')&&t.endsWith('"')||t.startsWith("'")&&t.endsWith("'"))&&(t=t.slice(1,-1));let e="",n=0;for(;n<t.length;)if(t[n]==="\\"&&n+1<t.length){const s=t[n+1];switch(s){case"n":e+=`
`;break;case"t":e+="	";break;case"r":e+="\r";break;case"\\":e+="\\";break;case'"':e+='"';break;case"'":e+="'";break;default:e+=s;break}n+=2}else e+=t[n],n++;return e}}const ut=new TextDecoder,wt=new Float32Array(32);for(let k=0;k<32;k++)wt[k]=Math.pow(2,k-15);const Dt=Math.pow(2,-14),y={Invalid:0,Bool:1,UChar:2,Int:3,UInt:4,Int64:5,UInt64:6,Half:7,Float:8,Double:9,String:10,Token:11,AssetPath:12,Matrix2d:13,Matrix3d:14,Matrix4d:15,Quatd:16,Quatf:17,Quath:18,Vec2d:19,Vec2f:20,Vec2h:21,Vec2i:22,Vec3d:23,Vec3f:24,Vec3h:25,Vec3i:26,Vec4d:27,Vec4f:28,Vec4i:30,Dictionary:31,TokenListOp:32,StringListOp:33,PathListOp:34,IntListOp:36,Int64ListOp:37,UIntListOp:38,UInt64ListOp:39,PathVector:40,TokenVector:41,Specifier:42,Permission:43,Variability:44,VariantSelectionMap:45,TimeSamples:46,DoubleVector:48},Rt=4294967295,Nt=105,Wt=116;function xt(k,t,e,n,s,i){for(;t<e;){const r=k[t++];if(t>e)break;let o=r>>4;if(o===15){let c;do{if(t>=e)break;c=k[t++],o+=c}while(c===255&&t<e)}if(o>0){t+o>e&&(o=e-t);for(let c=0;c<o&&!(s>=i);c++)n[s++]=k[t++]}if(t>=e||t+2>e)break;const l=k[t++]|k[t++]<<8;if(l===0)break;let f=(r&15)+4;if(f===19){let c;do{if(t>=e)break;c=k[t++],f+=c}while(c===255&&t<e)}const h=s-l;if(h<0)break;for(let c=0;c<f&&!(s>=i);c++)n[s++]=n[h+c]}return s}function dt(k,t){const e=new Uint8Array(t),n=k[0];if(n===0)return xt(k,1,k.length,e,0,t),e;{let i=1;const r=[];for(let f=0;f<n;f++){const h=(k[i]|k[i+1]<<8|k[i+2]<<16|k[i+3]<<24)>>>0;r.push(h),i+=4}let o=i,l=0;for(let f=0;f<n;f++){const h=r[f],c=Math.min(65536,t-l);xt(k,o,o+h,e,l,l+c),o+=h,l+=c}return e}}function G(k,t){const e=t*4+(t*2+7>>3)+4,n=dt(new Uint8Array(k),e);return jt(n,t)}function jt(k,t){const e=new DataView(k.buffer,k.byteOffset,k.byteLength);let n=0;const s=e.getInt32(n,!0);n+=4;const i=t*2+7>>3,r=n,o=n+i,l=new Int32Array(t);let f=0,h=r,c=o;for(let u=0;u<t;){const a=k[h++];for(let p=0;p<4&&u<t;p++,u++){const d=a>>p*2&3;let m=0;switch(d){case 0:m=s;break;case 1:m=e.getInt8(c),c+=1;break;case 2:m=e.getInt16(c,!0),c+=2;break;case 3:m=e.getInt32(c,!0),c+=4;break}f+=m,l[u]=f}}return l}class Lt{constructor(t){this.buffer=t,this.view=new DataView(t),this.offset=0}seek(t){this.offset=t}tell(){return this.offset}readUint8(){const t=this.view.getUint8(this.offset);return this.offset+=1,t}readInt8(){const t=this.view.getInt8(this.offset);return this.offset+=1,t}readUint16(){const t=this.view.getUint16(this.offset,!0);return this.offset+=2,t}readInt16(){const t=this.view.getInt16(this.offset,!0);return this.offset+=2,t}readUint32(){const t=this.view.getUint32(this.offset,!0);return this.offset+=4,t}readInt32(){const t=this.view.getInt32(this.offset,!0);return this.offset+=4,t}readUint64(){const t=this.view.getUint32(this.offset,!0),e=this.view.getUint32(this.offset+4,!0);return this.offset+=8,e*4294967296+t}readInt64(){const t=this.view.getUint32(this.offset,!0),e=this.view.getInt32(this.offset+4,!0);return this.offset+=8,e*4294967296+t}readFloat32(){const t=this.view.getFloat32(this.offset,!0);return this.offset+=4,t}readFloat64(){const t=this.view.getFloat64(this.offset,!0);return this.offset+=8,t}readBytes(t){const e=new Uint8Array(this.buffer,this.offset,t);return this.offset+=t,e}readString(t){const e=this.readBytes(t);let n=0;for(;n<t&&e[n]!==0;)n++;return ut.decode(e.subarray(0,n))}}class rt{constructor(t,e){this.lo=t,this.hi=e}get isArray(){return(this.hi&2147483648)!==0}get isInlined(){return(this.hi&1073741824)!==0}get isCompressed(){return(this.hi&536870912)!==0}get typeEnum(){return this.hi>>16&255}get payload(){return this.lo+(this.hi&65535)*4294967296}getInlinedValue(){return this.lo}}class zt{parseData(t){this.buffer=t instanceof ArrayBuffer?t:t.buffer,this.reader=new Lt(this.buffer),this.version={major:0,minor:0,patch:0},this._conversionBuffer=new ArrayBuffer(4),this._conversionView=new DataView(this._conversionBuffer),this._readBootstrap(),this._readTOC(),this._readTokens(),this._readStrings(),this._readFields(),this._readFieldSets(),this._readPaths(),this._readSpecs(),this.specsByPath={};for(const e of this.specs){const n=this.paths[e.pathIndex];if(!n)continue;const s=this._getFieldsForSpec(e);this.specsByPath[n]={specType:e.specType,fields:s}}return{specsByPath:this.specsByPath}}_readBootstrap(){const t=this.reader;if(t.seek(0),t.readString(8)!=="PXR-USDC")throw new Error("Not a valid USDC file");this.version.major=t.readUint8(),this.version.minor=t.readUint8(),this.version.patch=t.readUint8(),t.readBytes(5),this.tocOffset=t.readUint64()}_readTOC(){const t=this.reader;t.seek(this.tocOffset);const e=t.readUint64();this.sections={};for(let n=0;n<e;n++){const s=t.readString(16),i=t.readUint64(),r=t.readUint64();this.sections[s]={start:i,size:r}}}_readTokens(){const t=this.sections.TOKENS;if(!t)return;const e=this.reader;e.seek(t.start);const n=e.readUint64();if(this.tokens=[],this.version.major===0&&this.version.minor<4){const s=e.readUint64(),i=e.readBytes(s);let r=0;for(let o=0;o<n;o++){let l=r;for(;l<i.length&&i[l]!==0;)l++;this.tokens.push(ut.decode(i.subarray(r,l))),r=l+1}}else{const s=e.readUint64(),i=e.readUint64(),r=e.readBytes(i),o=dt(r,s);let l=0;for(let f=0;f<n;f++){let h=l;for(;h<o.length&&o[h]!==0;)h++;this.tokens.push(ut.decode(o.subarray(l,h))),l=h+1}}}_readStrings(){const t=this.sections.STRINGS;if(!t){this.strings=[];return}const e=this.reader;e.seek(t.start);const n=Math.floor(t.size/4);this.strings=[];for(let s=0;s<n;s++)this.strings.push(e.readUint32())}_readFields(){const t=this.sections.FIELDS;if(!t)return;const e=this.reader;if(e.seek(t.start),this.fields=[],this.version.major===0&&this.version.minor<4){const n=Math.floor(t.size/12);for(let s=0;s<n;s++){const i=e.readUint32(),r=e.readUint32(),o=e.readUint32();this.fields.push({tokenIndex:i,valueRep:new rt(r,o)})}}else{const n=e.readUint64(),s=e.readUint64(),i=e.readBytes(s),r=G(i.buffer.slice(i.byteOffset,i.byteOffset+s),n),o=e.readUint64(),l=e.readBytes(o),f=dt(l,n*8),h=new DataView(f.buffer,f.byteOffset,f.byteLength);for(let c=0;c<n;c++){const u=h.getUint32(c*8,!0),a=h.getUint32(c*8+4,!0);this.fields.push({tokenIndex:r[c],valueRep:new rt(u,a)})}}}_readFieldSets(){const t=this.sections.FIELDSETS;if(!t)return;const e=this.reader;if(e.seek(t.start),this.fieldSets=[],this.version.major===0&&this.version.minor<4){const n=Math.floor(t.size/4);for(let s=0;s<n;s++)this.fieldSets.push(e.readUint32())}else{const n=e.readUint64(),s=e.readUint64(),i=e.readBytes(s),r=G(i.buffer.slice(i.byteOffset,i.byteOffset+s),n);for(let o=0;o<n;o++)this.fieldSets.push(r[o])}}_readPaths(){const t=this.sections.PATHS;if(!t)return;const e=this.reader;e.seek(t.start);const n=e.readUint64();if(this.paths=new Array(n).fill(""),this.version.major===0&&this.version.minor<4)this._readPathsRecursive("");else{e.readUint64();const s=e.readUint64(),i=e.readBytes(s),r=G(i.buffer.slice(i.byteOffset,i.byteOffset+s),n),o=e.readUint64(),l=e.readBytes(o),f=G(l.buffer.slice(l.byteOffset,l.byteOffset+o),n),h=e.readUint64(),c=e.readBytes(h),u=G(c.buffer.slice(c.byteOffset,c.byteOffset+h),n);this._buildPathsFromCompressed(r,f,u)}}_readPathsRecursive(t,e=0){const n=this.reader;if(e>1e3)return;const s=n.readUint32(),i=n.readUint32(),r=n.readUint8(),o=(r&1)!==0,l=(r&2)!==0,f=(r&4)!==0;let h;if(t==="")h="/";else{const c=this.tokens[i]||"";f?h=t+"."+c:h=t==="/"?"/"+c:t+"/"+c}if(this.paths[s]=h,o&&l){const c=n.readUint64();this._readPathsRecursive(h,e+1),n.seek(c),this._readPathsRecursive(t,e+1)}else o?this._readPathsRecursive(h,e+1):l&&this._readPathsRecursive(t,e+1)}_buildPathsFromCompressed(t,e,n){const s=(i,r)=>{let o=i;for(;o<t.length;){const l=o++,f=t[l],h=e[l],c=n[l];let u;if(r==="")u="/",r=u;else{const d=this.tokens[Math.abs(h)]||"";h<0?u=r+"."+d:u=r==="/"?"/"+d:r+"/"+d}this.paths[f]=u;const a=c>0||c===-1,p=c>=0;if(a){if(p){const d=l+c;s(d,r)}r=u}else if(!p)break}};s(0,"")}_readSpecs(){const t=this.sections.SPECS;if(!t)return;const e=this.reader;if(e.seek(t.start),this.specs=[],this.version.major===0&&this.version.minor<4){const n=this.version.minor===0&&this.version.patch===1?16:12,s=Math.floor(t.size/n);for(let i=0;i<s;i++){const r=e.readUint32(),o=e.readUint32(),l=e.readUint32();n===16&&e.readUint32(),this.specs.push({pathIndex:r,fieldSetIndex:o,specType:l})}}else{const n=e.readUint64(),s=e.readUint64(),i=e.readBytes(s),r=G(i.buffer.slice(i.byteOffset,i.byteOffset+s),n),o=e.readUint64(),l=e.readBytes(o),f=G(l.buffer.slice(l.byteOffset,l.byteOffset+o),n),h=e.readUint64(),c=e.readBytes(h),u=G(c.buffer.slice(c.byteOffset,c.byteOffset+h),n);for(let a=0;a<n;a++)this.specs.push({pathIndex:r[a],fieldSetIndex:f[a],specType:u[a]})}}_readValue(t){const e=t.typeEnum,n=t.isArray,s=t.isInlined;if(e===y.TimeSamples)return this._readTimeSamples(t);if(s)return this._readInlinedValue(t);const i=t.payload,r=this.reader.tell();this.reader.seek(i);let o;return n?o=this._readArrayValue(t):o=this._readScalarValue(e),this.reader.seek(r),o}_readInlinedValue(t){const e=t.typeEnum,n=t.getInlinedValue(),s=this._conversionView;switch(e){case y.Bool:return n!==0;case y.UChar:return n&255;case y.Int:case y.UInt:return n;case y.Float:return s.setUint32(0,n,!0),s.getFloat32(0,!0);case y.Double:return s.setUint32(0,n,!0),s.getFloat32(0,!0);case y.Token:return this.tokens[n]||"";case y.String:return this.tokens[this.strings[n]]||"";case y.AssetPath:return this.tokens[n]||"";case y.Specifier:return n;case y.Permission:case y.Variability:return n;case y.Vec2h:return s.setUint32(0,n,!0),[this._halfToFloat(s.getUint16(0,!0)),this._halfToFloat(s.getUint16(2,!0))];case y.Vec2f:case y.Vec2i:return s.setUint32(0,n,!0),[s.getInt8(0),s.getInt8(1)];case y.Vec3f:case y.Vec3i:return s.setUint32(0,n,!0),[s.getInt8(0),s.getInt8(1),s.getInt8(2)];case y.Vec4f:case y.Vec4i:return s.setUint32(0,n,!0),[s.getInt8(0),s.getInt8(1),s.getInt8(2),s.getInt8(3)];case y.Matrix2d:{s.setUint32(0,n,!0);const i=s.getInt8(0),r=s.getInt8(1);return[i,0,0,r]}case y.Matrix3d:{s.setUint32(0,n,!0);const i=s.getInt8(0),r=s.getInt8(1),o=s.getInt8(2);return[i,0,0,0,r,0,0,0,o]}case y.Matrix4d:{s.setUint32(0,n,!0);const i=s.getInt8(0),r=s.getInt8(1),o=s.getInt8(2),l=s.getInt8(3);return[i,0,0,0,0,r,0,0,0,0,o,0,0,0,0,l]}default:return n}}_readTimeSamples(t){const e=this.reader,n=t.payload,s=e.tell();e.seek(n);const i=e.tell(),r=e.readInt64();e.seek(i+r);const o=e.readUint32(),l=e.readUint32(),f=new rt(o,l),h=this._readValue(f),c=i+r+8;e.seek(c);const u=e.tell(),a=e.readInt64();e.seek(u+a);const p=e.readUint64(),d=[];for(let b=0;b<p;b++){const P=e.readUint32(),g=e.readUint32();d.push(new rt(P,g))}const m=[];for(let b=0;b<p;b++)m.push(this._readValue(d[b]));return e.seek(s),{times:h instanceof Float64Array?Array.from(h):Array.isArray(h)?h:[h],values:m}}_readScalarValue(t){const e=this.reader;switch(t){case y.Invalid:return null;case y.Bool:return e.readUint8()!==0;case y.UChar:return e.readUint8();case y.Int:return e.readInt32();case y.UInt:return e.readUint32();case y.Int64:return e.readInt64();case y.UInt64:return e.readUint64();case y.Half:return this._readHalf();case y.Float:return e.readFloat32();case y.Double:return e.readFloat64();case y.String:case y.Token:{const n=e.readUint32();return this.tokens[n]||""}case y.AssetPath:{const n=e.readUint32();return this.tokens[n]||""}case y.Vec2f:return[e.readFloat32(),e.readFloat32()];case y.Vec2d:return[e.readFloat64(),e.readFloat64()];case y.Vec2i:return[e.readInt32(),e.readInt32()];case y.Vec3f:return[e.readFloat32(),e.readFloat32(),e.readFloat32()];case y.Vec3d:return[e.readFloat64(),e.readFloat64(),e.readFloat64()];case y.Vec3i:return[e.readInt32(),e.readInt32(),e.readInt32()];case y.Vec4f:return[e.readFloat32(),e.readFloat32(),e.readFloat32(),e.readFloat32()];case y.Vec4d:return[e.readFloat64(),e.readFloat64(),e.readFloat64(),e.readFloat64()];case y.Quatf:return[e.readFloat32(),e.readFloat32(),e.readFloat32(),e.readFloat32()];case y.Quatd:return[e.readFloat64(),e.readFloat64(),e.readFloat64(),e.readFloat64()];case y.Matrix4d:{const n=[];for(let s=0;s<16;s++)n.push(e.readFloat64());return n}case y.TokenVector:{const n=e.readUint64(),s=[];for(let i=0;i<n;i++){const r=e.readUint32();s.push(this.tokens[r]||"")}return s}case y.PathVector:{const n=e.readUint64(),s=[];for(let i=0;i<n;i++){const r=e.readUint32();s.push(this.paths[r]||"")}return s}case y.DoubleVector:{const n=e.readUint64(),s=new Float64Array(n);for(let i=0;i<n;i++)s[i]=e.readFloat64();return s}case y.Dictionary:{const n=e.readUint64(),s={};for(let i=0;i<n;i++){const r=e.readUint32(),o=this.tokens[r],l=e.position,f=e.readInt64(),h=l+f,c=e.position;e.position=h;const u=e.readUint64(),a=new rt(u);let p=null;a.isInlined?p=this._readInlinedValue(a):a.isArray?(e.position=a.payload,p=this._readArrayValue(a)):(e.position=a.payload,p=this._readScalarValue(a.typeEnum)),e.position=c,o!==void 0&&p!==null&&(s[o]=p)}return s}case y.TokenListOp:case y.StringListOp:case y.IntListOp:case y.Int64ListOp:case y.UIntListOp:case y.UInt64ListOp:return null;case y.PathListOp:{const n=e.readUint8(),s=(n&2)!==0,i=(n&4)!==0,r=(n&8)!==0,o=(n&16)!==0,l=(n&32)!==0,f=(n&64)!==0,h=()=>{const d=e.readUint64(),m=[];for(let _=0;_<d;_++){const b=e.readUint32();m.push(this.paths[b])}return m};let c=null,u=null,a=null,p=null;return s&&(c=h()),i&&(u=h()),l&&(a=h()),f&&(p=h()),r&&h(),o&&h(),a&&a.length>0?a:c&&c.length>0?c:p&&p.length>0?p:u&&u.length>0?u:null}case y.VariantSelectionMap:{const n=e.readUint64(),s={};for(let i=0;i<n;i++){const r=e.readUint32(),o=e.readUint32(),l=this.tokens[this.strings[r]],f=this.tokens[this.strings[o]];l&&f&&(s[l]=f)}return s}default:return console.warn("USDCParser: Unsupported scalar type",t),null}}_readArrayValue(t){const e=this.reader,n=t.typeEnum,s=t.isCompressed;let i;if(this.version.major===0&&this.version.minor<7?i=e.readUint32():i=e.readUint64(),i===0)return[];if(s)return this._readCompressedArray(n,i);switch(n){case y.Int:{const r=new Int32Array(i);for(let o=0;o<i;o++)r[o]=e.readInt32();return r}case y.UInt:{const r=new Uint32Array(i);for(let o=0;o<i;o++)r[o]=e.readUint32();return r}case y.Float:{const r=new Float32Array(i);for(let o=0;o<i;o++)r[o]=e.readFloat32();return r}case y.Double:{const r=new Float64Array(i);for(let o=0;o<i;o++)r[o]=e.readFloat64();return r}case y.Vec2f:{const r=new Float32Array(i*2);for(let o=0;o<i*2;o++)r[o]=e.readFloat32();return r}case y.Vec3f:{const r=new Float32Array(i*3);for(let o=0;o<i*3;o++)r[o]=e.readFloat32();return r}case y.Vec4f:{const r=new Float32Array(i*4);for(let o=0;o<i*4;o++)r[o]=e.readFloat32();return r}case y.Vec3h:{const r=new Float32Array(i*3);for(let o=0;o<i*3;o++)r[o]=this._readHalf();return r}case y.Quatf:{const r=new Float32Array(i*4);for(let o=0;o<i*4;o++)r[o]=e.readFloat32();return r}case y.Quath:{const r=new Float32Array(i*4);for(let o=0;o<i*4;o++)r[o]=this._readHalf();return r}case y.Matrix4d:{const r=new Float64Array(i*16);for(let o=0;o<i*16;o++)r[o]=e.readFloat64();return r}case y.Token:{const r=[];for(let o=0;o<i;o++){const l=e.readUint32();r.push(this.tokens[l]||"")}return r}case y.Half:{const r=new Float32Array(i);for(let o=0;o<i;o++)r[o]=this._readHalf();return r}default:return console.warn("USDCParser: Unsupported array type",n),[]}}_readCompressedArray(t,e){const n=this.reader;switch(t){case y.Int:case y.UInt:{const s=n.readUint64(),i=n.readBytes(s);return G(i.buffer.slice(i.byteOffset,i.byteOffset+s),e)}case y.Float:{const s=n.readInt8();if(s===Nt){const i=n.readUint64(),r=n.readBytes(i),o=G(r.buffer.slice(r.byteOffset,r.byteOffset+i),e),l=new Float32Array(e);for(let f=0;f<e;f++)l[f]=o[f];return l}else if(s===Wt){const i=n.readUint32(),r=new Float32Array(i);for(let c=0;c<i;c++)r[c]=n.readFloat32();const o=n.readUint64(),l=n.readBytes(o),f=G(l.buffer.slice(l.byteOffset,l.byteOffset+o),e),h=new Float32Array(e);for(let c=0;c<e;c++)h[c]=r[f[c]];return h}return console.warn("USDCParser: Unknown float compression code",s),new Float32Array(e)}default:return console.warn("USDCParser: Unsupported compressed array type",t),[]}}_readHalf(){return this._halfToFloat(this.reader.readUint16())}_halfToFloat(t){const e=(t&32768)>>15,n=(t&31744)>>10,s=t&1023;return n===0?s===0?e?-0:0:(e?-1:1)*Dt*(s/1024):n===31?s?NaN:e?-1/0:1/0:(e?-1:1)*wt[n]*(1+s/1024)}_getFieldsForSpec(t){const e={};let n=t.fieldSetIndex;const s=1e4;let i=0;for(;n<this.fieldSets.length&&i<s;){const r=this.fieldSets[n];if(r===Rt||r===-1)break;const o=this.fields[r];if(o){const l=this.tokens[o.tokenIndex],f=this._readValue(o.valueRep);e[l]=f}n++,i++}return e}}const Ht=/^(.+?)\/\{(\w+)=(\w+)\}\/(.+)$/,$={Attribute:1,Prim:6,Relationship:8};class J{constructor(t=null){this.textureCache={},this.skinnedMeshes=[],this.manager=t}compose(t,e={},n={},s=""){this.specsByPath=t.specsByPath,this.assets=e,this.externalVariantSelections=n,this.basePath=s,this.skinnedMeshes=[],this.skeletons={},this._buildIndexes();const i=this.specsByPath["/"],r=i?i.fields:{};this.fps=r.framesPerSecond||r.timeCodesPerSecond||30;const o=new pt;return this._buildHierarchy(o,"/"),this._bindSkeletons(),o.animations=this._buildAnimations(),i&&i.fields&&i.fields.upAxis==="Z"&&(o.rotation.x=-Math.PI/2),o}applyTransform(t,e,n={}){const s={...e,...n},i=s.xformOpOrder;if(i&&i.length>0){const r=new Z,o=new Z;let l=null;for(let f=0;f<i.length;f++){const h=i[f],c=h.startsWith("!invert!"),u=c?h.slice(8):h;if(u==="xformOp:transform"){const a=s["xformOp:transform"];a&&a.length===16&&(o.set(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15]),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:translate"){const a=s["xformOp:translate"];a&&(o.makeTranslation(a[0],a[1],a[2]),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:translate:pivot"){const a=s["xformOp:translate:pivot"];a&&(o.makeTranslation(a[0],a[1],a[2]),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:scale"){const a=s["xformOp:scale"];a&&(Array.isArray(a)?(o.makeScale(a[0],a[1],a[2]),l=[a[0],a[1],a[2]]):(o.makeScale(a,a,a),l=[a,a,a]),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:rotateXYZ"){const a=s["xformOp:rotateXYZ"];if(a){const p=new mt(a[0]*Math.PI/180,a[1]*Math.PI/180,a[2]*Math.PI/180,"ZYX");o.makeRotationFromEuler(p),c&&o.invert(),r.multiply(o)}}else if(u==="xformOp:rotateX"){const a=s["xformOp:rotateX"];a!==void 0&&(o.makeRotationX(a*Math.PI/180),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:rotateY"){const a=s["xformOp:rotateY"];a!==void 0&&(o.makeRotationY(a*Math.PI/180),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:rotateZ"){const a=s["xformOp:rotateZ"];a!==void 0&&(o.makeRotationZ(a*Math.PI/180),c&&o.invert(),r.multiply(o))}else if(u==="xformOp:orient"){const a=s["xformOp:orient"];if(a&&a.length===4){const p=new lt(a[0],a[1],a[2],a[3]);o.makeRotationFromQuaternion(p),c&&o.invert(),r.multiply(o)}}}if(t.matrix.copy(r),t.matrix.decompose(t.position,t.quaternion,t.scale),l){const f=l[0]<0,h=l[1]<0,c=l[2]<0;(f?1:0)+(h?1:0)+(c?1:0)===3&&(t.scale.set(l[0],l[1],l[2]),t.quaternion.set(t.quaternion.x,-t.quaternion.y,t.quaternion.z,-t.quaternion.w))}return}if(s["xformOp:translate"]){const r=s["xformOp:translate"];t.position.set(r[0],r[1],r[2])}if(s["xformOp:translate:pivot"]){const r=s["xformOp:translate:pivot"];t.pivot=new N(r[0],r[1],r[2])}if(s["xformOp:scale"]){const r=s["xformOp:scale"];Array.isArray(r)?t.scale.set(r[0],r[1],r[2]):t.scale.set(r,r,r)}if(s["xformOp:rotateXYZ"]){const r=s["xformOp:rotateXYZ"];t.rotation.set(r[0]*Math.PI/180,r[1]*Math.PI/180,r[2]*Math.PI/180)}if(s["xformOp:orient"]){const r=s["xformOp:orient"];r.length===4&&t.quaternion.set(r[0],r[1],r[2],r[3])}}_buildIndexes(){this.childrenByPath=new Map,this.attributesByPrimPath=new Map,this.materialsByRoot=new Map,this.shadersByMaterialPath=new Map,this.geomSubsetsByMeshPath=new Map;for(const t in this.specsByPath){const e=this.specsByPath[t];if(e.specType===$.Prim){const n=t.lastIndexOf("/");if(n>0){const i=t.slice(0,n),r=t.slice(n+1);this.childrenByPath.has(i)||this.childrenByPath.set(i,[]),this.childrenByPath.get(i).push({name:r,path:t})}else if(n===0&&t.length>1){const i=t.slice(1);this.childrenByPath.has("/")||this.childrenByPath.set("/",[]),this.childrenByPath.get("/").push({name:i,path:t})}const s=e.fields.typeName;if(s==="Material"){const i=t.split("/"),r=i.length>1?"/"+i[1]:"/";this.materialsByRoot.has(r)||this.materialsByRoot.set(r,[]),this.materialsByRoot.get(r).push(t)}if(s==="Shader"&&n>0){const i=t.slice(0,n);this.shadersByMaterialPath.has(i)||this.shadersByMaterialPath.set(i,[]),this.shadersByMaterialPath.get(i).push(t)}if(s==="GeomSubset"&&n>0){const i=t.slice(0,n);this.geomSubsetsByMeshPath.has(i)||this.geomSubsetsByMeshPath.set(i,[]),this.geomSubsetsByMeshPath.get(i).push(t)}}else if(e.specType===$.Attribute||e.specType===$.Relationship){const n=t.lastIndexOf(".");if(n>0){const s=t.slice(0,n),i=t.slice(n+1);this.attributesByPrimPath.has(s)||this.attributesByPrimPath.set(s,new Map),this.attributesByPrimPath.get(s).set(i,e)}}}}_isDirectChild(t,e,n){if(!e.startsWith(n))return!1;const s=e.slice(n.length);return s.length===0||s.startsWith("{")?!1:!s.includes("/")}_buildHierarchy(t,e){const n=[],s=new Set,i=this.childrenByPath.get(e);if(i)for(const o of i)s.has(o.path)||(s.add(o.path),n.push(o));const r=this._getVariantPaths(e);for(const o of r){const l=this.childrenByPath.get(o);if(l)for(const f of l)s.has(f.path)||(s.add(f.path),n.push(f))}for(const{name:o,path:l}of n){const f=this.specsByPath[l];if(!f||f.specType!==$.Prim)continue;const h=f.fields.typeName,c=this._getReference(f);if(c){const u=this._getLocalVariantSelections(f.fields),a=this._resolveReference(c,u);if(a){const p=this._getAttributes(l),d=this._findSingleMesh(a);if(d&&(h==="Xform"||!h))d.name=o,this.applyTransform(d,f.fields,p),this._applyMaterialBinding(d,l),t.add(d),this._buildHierarchy(d,l);else{const m=new ht;for(m.name=o,this.applyTransform(m,f.fields,p);a.children.length>0;)m.add(a.children[0]);t.add(m),this._buildHierarchy(m,l)}continue}}if(h==="SkelRoot"){const u=new ht;u.name=o,u.userData.isSkelRoot=!0;const a=this._getAttributes(l);this.applyTransform(u,f.fields,a),t.add(u),this._buildHierarchy(u,l)}else if(h==="Skeleton"){const u=this._buildSkeleton(l);u&&(this.skeletons[l]=u),this._buildHierarchy(t,l)}else if(h!=="SkelAnimation"){if(h==="Mesh"){const u=this._buildMesh(l,f);u&&t.add(u)}else if(!(h==="Material"||h==="Shader")){const u=new ht;u.name=o;const a=this._getAttributes(l);this.applyTransform(u,f.fields,a),t.add(u),this._buildHierarchy(u,l)}}}}_getVariantPaths(t){var i,r;const e=this.specsByPath[t],n=(i=e==null?void 0:e.fields)==null?void 0:i.variantSetChildren,s=[];if(!n||n.length===0)return s;for(const o of n){let l=this.externalVariantSelections[o]||null;if(!l){const f=e.fields.variantSelection;l=f?f[o]:null}if(!l){const f=t+"/{"+o+"=}",h=this.specsByPath[f];(r=h==null?void 0:h.fields)!=null&&r.variantChildren&&(l=h.fields.variantChildren[0])}if(l){const f=t+"/{"+o+"="+l+"}";s.push(f)}}return s}_resolveFilePath(t){let e=t;return e.startsWith("./")&&(e=e.slice(2)),this.basePath?this.basePath+"/"+e:e}_resolveReference(t,e={}){if(!t)return null;const n=t.match(/@([^@]+)@(?:<([^>]+)>)?/);if(!n)return null;const s=n[1],i=n[2],r=this._resolveFilePath(s),o={...e,...this.externalVariantSelections},l=this.assets[r];if(!l)return null;if(l.specsByPath){const f=new J(this.manager),h=this._getBasePath(r),c=f.compose(l,this.assets,o,h);if(i){const u=i.split("/").pop();let a=null;for(const p of c.children)if(p.name===u){a=p;break}if(a){c.remove(a);const p=new pt;return p.add(a),p}}return c}return l.isGroup||l.isObject3D?l.clone():null}_findSingleMesh(t){for(const e of t.children)if(e.isMesh)return t.remove(e),e;if(t.children.length===1){const e=t.children[0];if(e.children&&e.children.length===1){const n=e.children[0];if(n.isMesh&&!this._hasNonIdentityTransform(e))return e.remove(n),n}}return null}_hasNonIdentityTransform(t){const e=t.position,n=t.rotation,s=t.scale,i=e.x!==0||e.y!==0||e.z!==0,r=n.x!==0||n.y!==0||n.z!==0,o=s.x!==1||s.y!==1||s.z!==1;return i||r||o}_getBasePath(t){const e=t.lastIndexOf("/");return e>=0?t.slice(0,e):""}_getLocalVariantSelections(t){const e={};if(t.variantSelection)for(const n in t.variantSelection)e[n]=t.variantSelection[n];return e}_getReference(t){if(t.fields.references&&t.fields.references.length>0){const e=t.fields.references[0];if(typeof e=="string")return e;if(e.assetPath)return"@"+e.assetPath+"@"}if(t.fields.payload){const e=t.fields.payload;if(typeof e=="string")return e;if(e.assetPath)return"@"+e.assetPath+"@"}return null}_getAttributes(t){const e={};this._collectAttributesFromPath(t,e);const n=t.match(Ht);if(n){const s=n[1],i=n[4],r=this._getVariantPaths(s);for(const o of r){if(t.startsWith(o))continue;const l=o+"/"+i;this._collectAttributesFromPath(l,e)}}else{const s=t.split("/");for(let i=1;i<s.length-1;i++){const r=s.slice(0,i+1).join("/"),o=s.slice(i+1).join("/"),l=this._getVariantPaths(r);for(const f of l){const h=f+"/"+o;this._collectAttributesFromPath(h,e)}}}return e}_collectAttributesFromPath(t,e){var s,i,r,o;const n=this.attributesByPrimPath.get(t);if(n)for(const[l,f]of n){if(((s=f.fields)==null?void 0:s.default)!==void 0)e[l]=f.fields.default;else if((i=f.fields)!=null&&i.timeSamples){const{times:h,values:c}=f.fields.timeSamples;if(h&&c&&h.length>0){const u=h.indexOf(0);e[l]=u>=0?c[u]:c[0]}}((r=f.fields)==null?void 0:r.elementSize)!==void 0&&(e[l+":elementSize"]=f.fields.elementSize),l.startsWith("primvars:")&&((o=f.fields)==null?void 0:o.typeName)!==void 0&&(e[l+":typeName"]=f.fields.typeName)}}_buildMesh(t,e){const n=this._getAttributes(t),s=n["primvars:skel:jointIndices"],i=n["primvars:skel:jointWeights"],r=s&&i&&s.length>0&&i.length>0,o=this._getGeomSubsets(t);let l,f;if(o.length>0){l=this._buildGeometryWithSubsets(n,o,r);const a=this._getMaterialPath(t,e.fields);f=o.map(p=>{const d=p.materialPath||a;return this._buildMaterialForPath(d)})}else l=this._buildGeometry(t,n,r),f=this._buildMaterial(t,e.fields);const h=n["primvars:displayColor"];if(h&&h.length>=3){const a=p=>{p.color&&p.color.r===1&&p.color.g===1&&p.color.b===1&&!p.map&&p.color.setRGB(h[0],h[1],h[2],H)};Array.isArray(f)?f.forEach(a):a(f)}const c=n["primvars:displayOpacity"];if(c&&c.length>=1){const a=c[0],p=d=>{a<1&&(d.opacity=a,d.transparent=!0)};Array.isArray(f)?f.forEach(p):p(f)}let u;if(r){u=new It(l,f);let a=this.specsByPath[t+".skel:skeleton"];a||(a=this.specsByPath[t+".rel skel:skeleton"]);let p=null;a&&(a.fields.targetPaths&&a.fields.targetPaths.length>0?p=a.fields.targetPaths[0]:a.fields.default&&(p=a.fields.default.replace(/<|>/g,"")));const d=n["skel:joints"],m=n["primvars:skel:geomBindTransform"];this.skinnedMeshes.push({mesh:u,skeletonPath:p,path:t,localJoints:d,geomBindTransform:m})}else u=new vt(l,f);return u.name=t.split("/").pop(),this.applyTransform(u,e.fields,n),u}_getGeomSubsets(t){const e=[],n=this.geomSubsetsByMeshPath.get(t);if(!n)return e;for(const s of n){const r=this._getAttributes(s).indices;if(!r||r.length===0)continue;let o=this._getMaterialBindingTarget(s);e.push({name:s.split("/").pop(),indices:r,materialPath:o})}return e}_getMaterialBindingTarget(t){var r,o,l,f;const e="material:binding",n=t+"."+e,s=this.specsByPath[n];if(((o=(r=s==null?void 0:s.fields)==null?void 0:r.targetPaths)==null?void 0:o.length)>0)return s.fields.targetPaths[0];const i=t.split("/");for(let h=1;h<i.length;h++){const c=i.slice(0,h+1).join("/"),u=i.slice(h+1).join("/"),a=this._getVariantPaths(c);for(const p of a){const d=u?p+"/"+u+"."+e:p+"."+e,m=this.specsByPath[d];if(((f=(l=m==null?void 0:m.fields)==null?void 0:l.targetPaths)==null?void 0:f.length)>0)return m.fields.targetPaths[0]}}return null}_buildGeometry(t,e,n=!1){const s=new gt,i=e.points;if(!i||i.length===0)return s;const r=e.faceVertexIndices,o=e.faceVertexCounts,l=e["primvars:arnold:polygon_holes"],f=this._buildHoleMap(l);let h=r,c=null;if(o&&o.length>0){const g=this._triangulateIndicesWithPattern(r,o,i,f);h=g.indices,c=g.pattern}let u=i;h&&h.length>0&&(u=this._expandAttribute(i,h,3)),s.setAttribute("position",new W(new Float32Array(u),3));const a=e.normals||e["primvars:normals"],p=e["normals:indices"]||e["primvars:normals:indices"];if(a&&a.length>0){let g=a;if(p&&p.length>0&&c){const A=this._applyTriangulationPattern(p,c);g=this._expandAttribute(a,A,3)}else if(a.length===i.length)h&&h.length>0&&(g=this._expandAttribute(a,h,3));else if(c){const A=this._applyTriangulationPattern(Array.from({length:a.length/3},(w,S)=>S),c);g=this._expandAttribute(a,A,3)}s.setAttribute("normal",new W(new Float32Array(g),3))}else s.computeVertexNormals();const{uvs:d,uvIndices:m}=this._findUVPrimvar(e),_=r?r.length:0;if(d&&d.length>0){let g=d;if(m&&m.length>0&&c){const A=this._applyTriangulationPattern(m,c);g=this._expandAttribute(d,A,2)}else if(h&&d.length/2===i.length/3)g=this._expandAttribute(d,h,2);else if(c&&d.length/2===_){const A=this._applyTriangulationPattern(Array.from({length:_},(w,S)=>S),c);g=this._expandAttribute(d,A,2)}s.setAttribute("uv",new W(new Float32Array(g),2))}const{uvs2:b,uv2Indices:P}=this._findUV2Primvar(e);if(b&&b.length>0){let g=b;if(P&&P.length>0&&c){const A=this._applyTriangulationPattern(P,c);g=this._expandAttribute(b,A,2)}else if(h&&b.length/2===i.length/3)g=this._expandAttribute(b,h,2);else if(c&&b.length/2===_){const A=this._applyTriangulationPattern(Array.from({length:_},(w,S)=>S),c);g=this._expandAttribute(b,A,2)}s.setAttribute("uv1",new W(new Float32Array(g),2))}if(n){const g=e["primvars:skel:jointIndices"],A=e["primvars:skel:jointWeights"],w=e["primvars:skel:jointIndices:elementSize"]||4;if(g&&A){const S=u.length/3;let x,T;h&&h.length>0?(x=this._expandAttribute(g,h,w),T=this._expandAttribute(A,h,w)):(x=g,T=A);const F=new Uint16Array(S*4),v=new Float32Array(S*4);for(let V=0;V<S;V++)for(let M=0;M<4;M++)M<w?(F[V*4+M]=x[V*w+M]||0,v[V*4+M]=T[V*w+M]||0):(F[V*4+M]=0,v[V*4+M]=0);s.setAttribute("skinIndex",new W(F,4)),s.setAttribute("skinWeight",new W(v,4))}}return s}_buildGeometryWithSubsets(t,e,n=!1){const s=new gt,i=t.points;if(!i||i.length===0)return s;const r=t.faceVertexIndices,o=t.faceVertexCounts;if(!o||o.length===0)return s;const l=t["primvars:arnold:polygon_holes"],f=this._buildHoleMap(l),h=f.holeFaces,c=f.parentToHoles,{uvs:u,uvIndices:a}=this._findUVPrimvar(t),{uvs2:p,uv2Indices:d}=this._findUV2Primvar(t),m=t.normals||t["primvars:normals"],_=t["normals:indices"]||t["primvars:normals:indices"],b=n?t["primvars:skel:jointIndices"]:null,P=n?t["primvars:skel:jointWeights"]:null,g=t["primvars:skel:jointIndices:elementSize"]||4,A=[];let w=0;for(let I=0;I<o.length;I++){if(A.push(w),h.has(I))continue;const C=o[I],R=c.get(I);if(R&&R.length>0){let z=C;for(const B of R)z+=o[B];w+=z-2}else C>=3&&(w+=C-2)}const S=new Int32Array(w).fill(-1);for(let I=0;I<e.length;I++){const C=e[I];for(let R=0;R<C.indices.length;R++){const z=C.indices[R];if(z>=o.length)continue;const B=A[z],D=o[z]-2;for(let O=0;O<D;O++)S[B+O]=I}}const x=[];for(let I=0;I<w;I++)x.push({original:I,subset:S[I]});x.sort((I,C)=>I.subset-C.subset);const T=[];let F=x.length>0?x[0].subset:-1,v=0;for(let I=0;I<x.length;I++)x[I].subset!==F&&(F>=0&&T.push({start:v*3,count:(I-v)*3,materialIndex:F}),F=x[I].subset,v=I);F>=0&&x.length>v&&T.push({start:v*3,count:(x.length-v)*3,materialIndex:F});for(const I of T)s.addGroup(I.start,I.count,I.materialIndex);const{indices:V,pattern:M}=this._triangulateIndicesWithPattern(r,o,i,f),tt=a?this._applyTriangulationPattern(a,M):null,et=d?this._applyTriangulationPattern(d,M):null,st=o.reduce((I,C)=>I+C,0),ot=m&&_&&_.length>0,Y=m&&m.length/3===st,X=ot?this._applyTriangulationPattern(_,M):Y?this._applyTriangulationPattern(Array.from({length:st},(I,C)=>C),M):null,j=w*3,E=new Float32Array(j*3),U=u?new Float32Array(j*2):null,L=p?new Float32Array(j*2):null,q=m?new Float32Array(j*3):null,nt=b?new Uint16Array(j*4):null,it=P?new Float32Array(j*4):null;for(let I=0;I<x.length;I++){const C=x[I].original;for(let R=0;R<3;R++){const z=C*3+R,B=I*3+R,D=V[z];if(E[B*3]=i[D*3],E[B*3+1]=i[D*3+1],E[B*3+2]=i[D*3+2],U&&u)if(tt){const O=tt[z];U[B*2]=u[O*2],U[B*2+1]=u[O*2+1]}else u.length/2===i.length/3&&(U[B*2]=u[D*2],U[B*2+1]=u[D*2+1]);if(L&&p)if(et){const O=et[z];L[B*2]=p[O*2],L[B*2+1]=p[O*2+1]}else p.length/2===i.length/3&&(L[B*2]=p[D*2],L[B*2+1]=p[D*2+1]);if(q&&m)if(X){const O=X[z];q[B*3]=m[O*3],q[B*3+1]=m[O*3+1],q[B*3+2]=m[O*3+2]}else m.length===i.length&&(q[B*3]=m[D*3],q[B*3+1]=m[D*3+1],q[B*3+2]=m[D*3+2]);if(nt&&it&&b&&P)for(let O=0;O<4;O++)O<g?(nt[B*4+O]=b[D*g+O]||0,it[B*4+O]=P[D*g+O]||0):(nt[B*4+O]=0,it[B*4+O]=0)}}return s.setAttribute("position",new W(E,3)),U&&s.setAttribute("uv",new W(U,2)),L&&s.setAttribute("uv1",new W(L,2)),q?s.setAttribute("normal",new W(q,3)):s.computeVertexNormals(),nt&&s.setAttribute("skinIndex",new W(nt,4)),it&&s.setAttribute("skinWeight",new W(it,4)),s}_findUVPrimvar(t){for(const s in t){if(!s.startsWith("primvars:")||s.endsWith(":typeName")||s.endsWith(":elementSize")||s.endsWith(":indices")||s.includes("skel:"))continue;const i=t[s+":typeName"];if(i&&i.includes("texCoord"))return{uvs:t[s],uvIndices:t[s+":indices"]}}const e=t["primvars:st"]||t["primvars:UVMap"],n=t["primvars:st:indices"];return{uvs:e,uvIndices:n}}_findUV2Primvar(t){const e=t["primvars:st1"],n=t["primvars:st1:indices"];return{uvs2:e,uv2Indices:n}}_buildHoleMap(t){if(!t||t.length===0)return{parentToHoles:new Map,holeFaces:new Set};const e=new Map,n=new Set;for(let s=0;s<t.length;s+=2){const i=t[s],r=t[s+1];n.add(i),e.has(r)||e.set(r,[]),e.get(r).push(i)}return{parentToHoles:e,holeFaces:n}}_triangulateIndicesWithPattern(t,e,n=null,s=null){const i=[],r=[],o=[];let l=0;for(let u=0;u<e.length;u++)o.push(l),l+=e[u];const f=(s==null?void 0:s.parentToHoles)||new Map,h=(s==null?void 0:s.holeFaces)||new Set;let c=0;for(let u=0;u<e.length;u++){const a=e[u];if(h.has(u)){c+=a;continue}const p=f.get(u);if(p&&p.length>0&&n&&n.length>0){const d=new Map,m=[];for(let P=0;P<a;P++){const g=t[c+P];m.push(g),d.set(g,c+P)}const _=[];for(const P of p){const g=o[P],A=e[P],w=[];for(let S=0;S<A;S++){const x=t[g+S];w.push(x),d.set(x,g+S)}_.push(w)}const b=this._triangulateNGonWithHoles(m,_,n);for(const P of b)i.push(P[0],P[1],P[2]),r.push(d.get(P[0]),d.get(P[1]),d.get(P[2]))}else if(a===3)i.push(t[c],t[c+1],t[c+2]),r.push(c,c+1,c+2);else if(a===4)i.push(t[c],t[c+1],t[c+2],t[c],t[c+2],t[c+3]),r.push(c,c+1,c+2,c,c+2,c+3);else if(a>4)if(n&&n.length>0){const d=[];for(let _=0;_<a;_++)d.push(t[c+_]);const m=this._triangulateNGon(d,n);for(const _ of m)i.push(_[0],_[1],_[2]),r.push(c+d.indexOf(_[0]),c+d.indexOf(_[1]),c+d.indexOf(_[2]))}else for(let d=1;d<a-1;d++)i.push(t[c],t[c+d],t[c+d+1]),r.push(c,c+d,c+d+1);c+=a}return{indices:i,pattern:r}}_applyTriangulationPattern(t,e){const n=[];for(let s=0;s<e.length;s++)n.push(t[e[s]]);return n}_triangulateNGon(t,e){const n=[],s=[];for(const h of t)s.push(new N(e[h*3],e[h*3+1],e[h*3+2]));const i=new N;for(let h=0;h<s.length;h++){const c=s[h],u=s[(h+1)%s.length];i.x+=(c.y-u.y)*(c.z+u.z),i.y+=(c.z-u.z)*(c.x+u.x),i.z+=(c.x-u.x)*(c.y+u.y)}i.normalize();const r=new N,o=new N;Math.abs(i.y)>.9?r.set(1,0,0):r.set(0,1,0),o.crossVectors(i,r).normalize(),r.crossVectors(o,i).normalize();for(const h of s)n.push(new at(h.dot(r),h.dot(o)));const l=yt.triangulateShape(n,[]),f=[];for(const h of l)f.push([t[h[0]],t[h[1]],t[h[2]]]);return f}_triangulateNGonWithHoles(t,e,n){const s=[];for(const a of t)s.push(new N(n[a*3],n[a*3+1],n[a*3+2]));const i=new N;for(let a=0;a<s.length;a++){const p=s[a],d=s[(a+1)%s.length];i.x+=(p.y-d.y)*(p.z+d.z),i.y+=(p.z-d.z)*(p.x+d.x),i.z+=(p.x-d.x)*(p.y+d.y)}i.normalize();const r=new N,o=new N;Math.abs(i.y)>.9?r.set(1,0,0):r.set(0,1,0),o.crossVectors(i,r).normalize(),r.crossVectors(o,i).normalize();const l=[];for(const a of s)l.push(new at(a.dot(r),a.dot(o)));const f=[];for(const a of e){const p=[];for(const d of a){const m=new N(n[d*3],n[d*3+1],n[d*3+2]);p.push(new at(m.dot(r),m.dot(o)))}f.push(p)}const h=[...t];for(const a of e)h.push(...a);const c=yt.triangulateShape(l,f),u=[];for(const a of c)u.push([h[a[0]],h[a[1]],h[a[2]]]);return u}_triangulateIndices(t,e){const n=[];let s=0;for(let i=0;i<e.length;i++){const r=e[i];if(r===3)n.push(t[s],t[s+1],t[s+2]);else if(r===4)n.push(t[s],t[s+1],t[s+2],t[s],t[s+2],t[s+3]);else if(r>4)for(let o=1;o<r-1;o++)n.push(t[s],t[s+o],t[s+o+1]);s+=r}return n}_expandAttribute(t,e,n){const s=new Array(e.length*n);for(let i=0;i<e.length;i++){const r=e[i];for(let o=0;o<n;o++)s[i*n+o]=t[r*n+o]}return s}_getMaterialPath(t,e){let n=null,s=e["material:binding"];return s&&(n=Array.isArray(s)?s[0]:s),n||(n=this._getMaterialBindingTarget(t)),n}_buildMaterial(t,e){const n=new ft;let s=null,i=e["material:binding"];if(i&&(s=Array.isArray(i)?i[0]:i),s||(s=this._getMaterialBindingTarget(t)),!s){const r=[],o=t+"/";for(const l in this.specsByPath){if(!l.startsWith(o)||!l.endsWith(".material:binding"))continue;const f=this.specsByPath[l];if(!f)continue;const h=f.fields.targetPaths;h&&h.length>0&&r.push(h[0])}r.length>0&&(s=this._pickBestMaterial(r))}if(!s){const o="/"+t.split("/")[1],l=this.materialsByRoot.get(o);if(l){for(const f of l)if(f.startsWith(o+"/Looks/")||f.startsWith(o+"/Materials/")){s=f;break}}}return s&&this._applyMaterial(n,s),n}_buildMaterialForPath(t){const e=new ft;return t&&this._applyMaterial(e,t),e}_applyMaterialBinding(t,e){var l,f;const n=e+".material:binding",s=this.specsByPath[n];if(!s)return;let i=null;const r=((l=s.fields)==null?void 0:l.targetPaths)||((f=s.fields)==null?void 0:f.default);if(r&&(i=Array.isArray(r)?r[0]:r),!i)return;i=String(i).replace(/^<|>$/g,"");const o=new ft;this._applyMaterial(o,i),t.material=o}_pickBestMaterial(t){for(const e of t){const n=this.shadersByMaterialPath.get(e);if(n)for(const s of n){const i=this._getAttributes(s);if(i["info:id"]==="UsdUVTexture"&&i["inputs:file"])return e}}return t[0]}_applyMaterial(t,e){if(!this.specsByPath[e])return;const s=this.shadersByMaterialPath.get(e);if(s)for(const i of s){const r=this.specsByPath[i];if(!r)continue;const l=this._getAttributes(i)["info:id"]||r.fields["info:id"];l==="UsdPreviewSurface"?this._applyPreviewSurface(t,i):l==="arnold:openpbr_surface"&&this._applyOpenPBRSurface(t,i)}}_applyTextureOrValue(t,e,n,s,i,r,o,l){const f=e+"."+s,h=this.specsByPath[f];if(h&&h.fields.connectionPaths&&h.fields.connectionPaths.length>0){const c=l===this._getTextureFromOpenPBRConnection?h.fields.connectionPaths:[h.fields.connectionPaths[0]];for(const u of c){const a=l.call(this,u);if(a)return a.colorSpace=r,t[i]=a,!0}}return n[s]!==void 0&&o&&o(n[s]),!1}_applyPreviewSurface(t,e){var c,u;const n=this._getAttributes(e),s=(a,p,d,m)=>this._applyTextureOrValue(t,e,n,a,p,d,m,this._getTextureFromConnection),i=a=>{const p=e+"."+a;return this.specsByPath[p]};if(s("inputs:diffuseColor","map",H,a=>{Array.isArray(a)&&a.length>=3&&t.color.setRGB(a[0],a[1],a[2],H)}),s("inputs:emissiveColor","emissiveMap",H,a=>{Array.isArray(a)&&a.length>=3&&t.emissive.setRGB(a[0],a[1],a[2],H)}),t.emissiveMap&&t.emissive.set(16777215),s("inputs:normal","normalMap",Q,null),t.normalMap&&t.normalMap.userData.scale){const a=t.normalMap.userData.scale;t.normalScale=new at(a[0],a[1])}s("inputs:roughness","roughnessMap",Q,a=>{t.roughness=a})&&(t.roughness=1),s("inputs:metallic","metalnessMap",Q,a=>{t.metalness=a})&&(t.metalness=1),s("inputs:occlusion","aoMap",Q,null),n["inputs:ior"]!==void 0&&(t.ior=n["inputs:ior"]),s("inputs:specularColor","specularColorMap",H,a=>{Array.isArray(a)&&a.length>=3&&t.specularColor.setRGB(a[0],a[1],a[2],H)}),n["inputs:clearcoat"]!==void 0&&(t.clearcoat=n["inputs:clearcoat"]),n["inputs:clearcoatRoughness"]!==void 0&&(t.clearcoatRoughness=n["inputs:clearcoatRoughness"]);const l=n["inputs:opacityThreshold"]!==void 0?n["inputs:opacityThreshold"]:0,f=i("inputs:opacity");if(((u=(c=f==null?void 0:f.fields)==null?void 0:c.connectionPaths)==null?void 0:u.length)>0)l>0?(t.alphaTest=l,t.transparent=!1):t.transparent=!0;else{const a=n["inputs:opacity"]!==void 0?n["inputs:opacity"]:1;a<1&&(t.transparent=!0,t.opacity=a)}}_applyOpenPBRSurface(t,e){const n=this._getAttributes(e),s=(d,m,_,b)=>this._applyTextureOrValue(t,e,n,d,m,_,b,this._getTextureFromOpenPBRConnection);s("inputs:base_color","map",H,d=>{Array.isArray(d)&&d.length>=3&&t.color.setRGB(d[0],d[1],d[2],H)}),s("inputs:base_metalness","metalnessMap",Q,d=>{typeof d=="number"&&(t.metalness=d)}),s("inputs:specular_roughness","roughnessMap",Q,d=>{typeof d=="number"&&(t.roughness=d)});const i=s("inputs:emission_color","emissiveMap",H,d=>{Array.isArray(d)&&d.length>=3&&t.emissive.setRGB(d[0],d[1],d[2],H)}),r=n["inputs:emission_luminance"];r!==void 0&&r>0&&(i?t.emissiveIntensity=r:t.emissive.multiplyScalar(r));const o=n["inputs:transmission_weight"];if(o!==void 0&&o>0){t.transmission=o;const d=n["inputs:transmission_depth"];d!==void 0&&(t.thickness=d);const m=n["inputs:transmission_color"];m!==void 0&&Array.isArray(m)&&(t.attenuationColor.setRGB(m[0],m[1],m[2]),t.attenuationDistance=d||1)}const l=n["inputs:geometry_opacity"];l!==void 0&&l<1&&(t.opacity=l,t.transparent=!0);const f=n["inputs:specular_ior"];f!==void 0&&(t.ior=f);const h=n["inputs:coat_weight"];if(h!==void 0&&h>0){t.clearcoat=h;const d=n["inputs:coat_roughness"];d!==void 0&&(t.clearcoatRoughness=d)}const c=n["inputs:thin_film_weight"];if(c!==void 0&&c>0){t.iridescence=c;const d=n["inputs:thin_film_ior"];d!==void 0&&(t.iridescenceIOR=d);const m=n["inputs:thin_film_thickness"];if(m!==void 0){const _=m*1e3;t.iridescenceThicknessRange=[_,_]}}const u=n["inputs:specular_weight"];u!==void 0&&(t.specularIntensity=u);const a=n["inputs:specular_color"];a!==void 0&&Array.isArray(a)&&t.specularColor.setRGB(a[0],a[1],a[2]);const p=n["inputs:specular_roughness_anisotropy"];p!==void 0&&p>0&&(t.anisotropy=p),s("inputs:geometry_normal","normalMap",Q,null)}_getTextureFromOpenPBRConnection(t){var f,h,c,u,a,p,d,m,_,b;const e=t.replace(/<|>/g,""),n=e.split(".")[0],s=this.specsByPath[n];if(!s)return null;const i=this._getAttributes(n),r=i["info:id"]||s.fields["info:id"];if(s.fields.typeName==="NodeGraph"){const P=e.split(".")[1],g=n+"."+P,A=this.specsByPath[g];return((h=(f=A==null?void 0:A.fields)==null?void 0:f.connectionPaths)==null?void 0:h.length)>0?this._getTextureFromOpenPBRConnection(A.fields.connectionPaths[0]):null}if(r==="arnold:image"){const P=i["inputs:filename"];return P?this._loadTextureFromPath(P):null}if(r&&r.startsWith("ND_image_")){const P=i["inputs:file"];return P?this._loadTextureFromPath(P):null}if(r==="MayaND_fileTexture_color4"){const P=n+".inputs:inColor",g=this.specsByPath[P];return((u=(c=g==null?void 0:g.fields)==null?void 0:c.connectionPaths)==null?void 0:u.length)>0?this._getTextureFromOpenPBRConnection(g.fields.connectionPaths[0]):null}if(r&&r.startsWith("ND_convert_")){const P=n+".inputs:in",g=this.specsByPath[P];return((p=(a=g==null?void 0:g.fields)==null?void 0:a.connectionPaths)==null?void 0:p.length)>0?this._getTextureFromOpenPBRConnection(g.fields.connectionPaths[0]):null}if(r==="arnold:bump2d"){const P=n+".inputs:bump_map",g=this.specsByPath[P];return((m=(d=g==null?void 0:g.fields)==null?void 0:d.connectionPaths)==null?void 0:m.length)>0?this._getTextureFromOpenPBRConnection(g.fields.connectionPaths[0]):null}if(r==="arnold:color_correct"){const P=n+".inputs:input",g=this.specsByPath[P];return((b=(_=g==null?void 0:g.fields)==null?void 0:_.connectionPaths)==null?void 0:b.length)>0?this._getTextureFromOpenPBRConnection(g.fields.connectionPaths[0]):null}const l=n.substring(0,n.lastIndexOf("/"));if(l){const P=this.specsByPath[l];if(P){const g=this._getAttributes(l);if((g["info:id"]||P.fields["info:id"])==="arnold:image"){const w=g["inputs:filename"];if(w)return this._loadTextureFromPath(w)}}}return null}_loadTextureFromPath(t){if(!t)return null;if(this.textureCache[t])return this.textureCache[t];const e=this._loadTexture(t,null,null);return e&&(this.textureCache[t]=e),e}_getTextureFromConnection(t){var d,m,_,b;const e=t.split(".")[0],n=this.specsByPath[e];if(!n)return null;const s=this._getAttributes(e);if((s["info:id"]||n.fields["info:id"])!=="UsdUVTexture")return null;const r=s["inputs:file"];if(!r)return null;let o=null,l=0;const f=e+".inputs:st",h=this.specsByPath[f];if(((m=(d=h==null?void 0:h.fields)==null?void 0:d.connectionPaths)==null?void 0:m.length)>0){const g=h.fields.connectionPaths[0].replace(/<|>/g,"").split(".")[0],A=this.specsByPath[g];if(A){const w=this._getAttributes(g),S=w["info:id"]||A.fields["info:id"];if(S==="UsdTransform2d"){o=w;const x=g+".inputs:in",T=this.specsByPath[x];if(((b=(_=T==null?void 0:T.fields)==null?void 0:_.connectionPaths)==null?void 0:b.length)>0){const v=T.fields.connectionPaths[0].replace(/<|>/g,"").split(".")[0],M=this._getAttributes(v)["inputs:varname"];M==="st1"?l=1:M==="st2"&&(l=2)}}else if(S==="UsdPrimvarReader_float2"){const x=w["inputs:varname"];x==="st1"?l=1:x==="st2"&&(l=2)}}}const c=s["inputs:scale"],u=s["inputs:bias"];let a=r;if(c&&(a+=":s"+c.join(",")),u&&(a+=":b"+u.join(",")),this.textureCache[a])return this.textureCache[a];const p=this._loadTexture(r,s,o);return p&&(c&&(p.userData.scale=c),u&&(p.userData.bias=u),l!==0&&(p.channel=l),this.textureCache[a]=p),p}_applyTextureTransforms(t,e){if(!e)return;const n=e["inputs:scale"];n&&Array.isArray(n)&&n.length>=2&&t.repeat.set(n[0],n[1]);const s=e["inputs:translation"];s&&Array.isArray(s)&&s.length>=2&&t.offset.set(s[0],s[1]);const i=e["inputs:rotation"];typeof i=="number"&&(t.rotation=i*Math.PI/180)}_loadTexture(t,e,n){let s=t;s.startsWith("@")&&(s=s.slice(1)),s.endsWith("@")&&(s=s.slice(0,-1));const i=this._resolveFilePath(s);let r=this.assets[i];if(r||(r=this.assets[s]),!r){const o=s.split("/").pop();for(const l in this.assets)if(l.endsWith(o)||l.endsWith("/"+o))return this._createTextureFromData(this.assets[l],e,n);if(this.manager){const l=this.manager.resolveURL(o);if(l!==o)return this._createTextureFromData(l,e,n)}return console.warn("USDLoader: Texture not found:",s),null}return this._createTextureFromData(r,e,n)}_createTextureFromData(t,e,n){if(!t)return null;const s=this,i=new At;let r;if(typeof t=="string")r=t;else if(t instanceof Uint8Array||t instanceof ArrayBuffer){const l=new Blob([t]);r=URL.createObjectURL(l)}else return null;const o=new Image;return o.onload=function(){i.image=o,e&&(i.wrapS=s._getWrapMode(e["inputs:wrapS"]),i.wrapT=s._getWrapMode(e["inputs:wrapT"])),s._applyTextureTransforms(i,n),i.needsUpdate=!0,typeof t!="string"&&URL.revokeObjectURL(r)},o.src=r,i}_getWrapMode(t){return t==="repeat"?Pt:t==="mirror"?kt:t==="clamp"?St:Pt}_buildSkeleton(t){const e=this._getAttributes(t),n=e.joints;if(!n||n.length===0)return null;const s=e.bindTransforms,i=e.restTransforms,r=this._flattenMatrixArray(s,n.length),o=this._flattenMatrixArray(i,n.length),l=[],f={},h=[];for(let p=0;p<n.length;p++){const d=n[p],m=d.split("/").pop(),_=new Ft;if(_.name=m,l.push(_),f[d]={bone:_,index:p},r&&r.length>=(p+1)*16){const b=new Z,P=r.slice(p*16,(p+1)*16);b.set(P[0],P[4],P[8],P[12],P[1],P[5],P[9],P[13],P[2],P[6],P[10],P[14],P[3],P[7],P[11],P[15]);const g=b.clone().invert();h.push(g)}else h.push(new Z)}for(let p=0;p<n.length;p++){const m=n[p].split("/");if(m.length>1){const _=m.slice(0,-1).join("/"),b=f[_];b&&b.bone.add(l[p])}}if(o&&o.length>=n.length*16)for(let p=0;p<n.length;p++){const d=new Z,m=o.slice(p*16,(p+1)*16);d.set(m[0],m[4],m[8],m[12],m[1],m[5],m[9],m[13],m[2],m[6],m[10],m[14],m[3],m[7],m[11],m[15]),d.decompose(l[p].position,l[p].quaternion,l[p].scale)}const c=l.filter(p=>!p.parent||!p.parent.isBone),u=this.specsByPath[t+".skel:animationSource"];let a=null;return u&&u.fields.targetPaths&&u.fields.targetPaths.length>0&&(a=u.fields.targetPaths[0]),{skeleton:new Tt(l,h),joints:n,rootBones:c,animationPath:a,path:t}}_bindSkeletons(){for(const t of this.skinnedMeshes){const{mesh:e,skeletonPath:n,localJoints:s,geomBindTransform:i}=t;let r=null;if(n&&this.skeletons[n]&&(r=this.skeletons[n]),!r){for(const c in this.skeletons)if(n&&(n.includes(c)||c.includes(n))){r=this.skeletons[c];break}}if(!r){const c=Object.keys(this.skeletons);c.length>0&&(r=this.skeletons[c[0]])}if(!r){console.warn("USDComposer: No skeleton found for skinned mesh",e.name);continue}const{skeleton:o,rootBones:l,joints:f}=r;if(s&&s.length>0){const c=e.geometry.attributes.skinIndex;if(c){const u=[];for(let p=0;p<s.length;p++){const d=s[p],m=f.indexOf(d);u[p]=m>=0?m:0}const a=c.array;for(let p=0;p<a.length;p++){const d=a[p];d<u.length&&(a[p]=u[d])}}}for(const c of l)e.add(c);let h=new Z;if(i&&i.length===16){const c=i;h.set(c[0],c[4],c[8],c[12],c[1],c[5],c[9],c[13],c[2],c[6],c[10],c[14],c[3],c[7],c[11],c[15])}else h=this._computeGeomBindTransform(e,o);e.bind(o,h)}}_computeGeomBindTransform(t,e){const n=new Z,s=t.geometry,i=s.attributes.position,r=s.attributes.skinIndex;if(!i||!r||i.count===0)return n;const o=e.boneInverses,l=Math.min(50,i.count);let f=0,h=0,c=0,u=0;for(let a=0;a<l;a++){const p=Math.floor(a*i.count/l),d=i.getX(p),m=i.getY(p),_=i.getZ(p),b=r.getX(p);if(b>=o.length)continue;const g=o[b].clone().invert(),A=g.elements[12],w=g.elements[13],S=g.elements[14];Math.abs(d)>.001&&Math.abs(A)>.001&&(f+=A/d,h+=w/m,c+=S/_,u++)}if(u>0){const a=(f+h+c)/(u*3);Math.abs(a-1)>.1&&n.makeScale(a,a,a)}return n}_buildAnimations(){const t=[];for(const n in this.specsByPath){const s=this.specsByPath[n];if(s.specType!==$.Prim||s.fields.typeName!=="SkelAnimation")continue;const i=this._buildAnimationClip(n);i&&t.push(i)}const e=this._buildTransformAnimations();return e.length>0&&t.push(new _t("TransformAnimation",-1,e)),t}_buildTransformAnimations(){var e,n,s,i,r,o,l;const t=[];for(const f in this.specsByPath){const h=this.specsByPath[f];if(h.specType!==$.Prim)continue;const c=(e=h.fields)==null?void 0:e.typeName;if(c!=="Xform"&&c!=="Scope"&&c!=="Mesh")continue;const u=f.split("/").pop(),a=f+".xformOp:orient",p=this.specsByPath[a];if((n=p==null?void 0:p.fields)!=null&&n.timeSamples){const{times:w,values:S}=p.fields.timeSamples,x=[],T=[];for(let F=0;F<w.length;F++){x.push(w[F]/this.fps);const v=S[F];T.push(v[0],v[1],v[2],v[3])}x.length>0&&t.push(new ct(u+".quaternion",new Float32Array(x),new Float32Array(T)))}const d=f+".xformOp:rotateXYZ",m=this.specsByPath[d];if((s=m==null?void 0:m.fields)!=null&&s.timeSamples){const{times:w,values:S}=m.fields.timeSamples,x=[],T=[],F=new mt,v=new lt;for(let V=0;V<w.length;V++){x.push(w[V]/this.fps);const M=S[V];F.set(M[0]*Math.PI/180,M[1]*Math.PI/180,M[2]*Math.PI/180,"ZYX"),v.setFromEuler(F),T.push(v.x,v.y,v.z,v.w)}x.length>0&&t.push(new ct(u+".quaternion",new Float32Array(x),new Float32Array(T)))}const _=f+".xformOp:translate",b=this.specsByPath[_];if((i=b==null?void 0:b.fields)!=null&&i.timeSamples){const{times:w,values:S}=b.fields.timeSamples,x=[],T=[];for(let F=0;F<w.length;F++){x.push(w[F]/this.fps);const v=S[F];T.push(v[0],v[1],v[2])}x.length>0&&t.push(new K(u+".position",new Float32Array(x),new Float32Array(T)))}const P=f+".xformOp:scale",g=this.specsByPath[P];if((r=g==null?void 0:g.fields)!=null&&r.timeSamples){const{times:w,values:S}=g.fields.timeSamples,x=[],T=[];for(let F=0;F<w.length;F++){x.push(w[F]/this.fps);const v=S[F];T.push(v[0],v[1],v[2])}x.length>0&&t.push(new K(u+".scale",new Float32Array(x),new Float32Array(T)))}const A=((o=h.fields)==null?void 0:o.properties)||[];for(const w of A){if(!w.startsWith("xformOp:transform"))continue;const S=f+"."+w,x=this.specsByPath[S];if(!((l=x==null?void 0:x.fields)!=null&&l.timeSamples))continue;const{times:T,values:F}=x.fields.timeSamples,v=[],V=[],M=[],tt=[],et=[],st=[],ot=new Z,Y=new N,X=new lt,j=new N;for(let E=0;E<T.length;E++){const U=F[E];if(!U||U.length<16)continue;const L=T[E]/this.fps;ot.set(U[0],U[4],U[8],U[12],U[1],U[5],U[9],U[13],U[2],U[6],U[10],U[14],U[3],U[7],U[11],U[15]),ot.decompose(Y,X,j),v.push(L),V.push(Y.x,Y.y,Y.z),M.push(L),tt.push(X.x,X.y,X.z,X.w),et.push(L),st.push(j.x,j.y,j.z)}v.length>0&&(t.push(new K(u+".position",new Float32Array(v),new Float32Array(V))),t.push(new ct(u+".quaternion",new Float32Array(M),new Float32Array(tt))),t.push(new K(u+".scale",new Float32Array(et),new Float32Array(st))));break}}return t}_buildAnimationClip(t){const n=this._getAttributes(t).joints;if(!n||n.length===0)return null;const s=[],i=this._getTimeSampledAttribute(t,"rotations");if(i&&i.times&&i.values){const{times:f,values:h}=i;for(let c=0;c<n.length;c++){const u=n[c].split("/").pop(),a=[],p=[];for(let d=0;d<f.length;d++){const m=h[d];if(!m||m.length<(c+1)*4)continue;a.push(f[d]/this.fps);const _=m[c*4+0],b=m[c*4+1],P=m[c*4+2],g=m[c*4+3];p.push(_,b,P,g)}a.length>0&&s.push(new ct(u+".quaternion",new Float32Array(a),new Float32Array(p)))}}const r=this._getTimeSampledAttribute(t,"translations");if(r&&r.times&&r.values){const{times:f,values:h}=r;for(let c=0;c<n.length;c++){const u=n[c].split("/").pop(),a=[],p=[];for(let d=0;d<f.length;d++){const m=h[d];!m||m.length<(c+1)*3||(a.push(f[d]/this.fps),p.push(m[c*3+0],m[c*3+1],m[c*3+2]))}a.length>0&&s.push(new K(u+".position",new Float32Array(a),new Float32Array(p)))}}const o=this._getTimeSampledAttribute(t,"scales");if(o&&o.times&&o.values){const{times:f,values:h}=o;for(let c=0;c<n.length;c++){const u=n[c].split("/").pop(),a=[],p=[];for(let d=0;d<f.length;d++){const m=h[d];!m||m.length<(c+1)*3||(a.push(f[d]/this.fps),p.push(m[c*3+0],m[c*3+1],m[c*3+2]))}a.length>0&&s.push(new K(u+".scale",new Float32Array(a),new Float32Array(p)))}}if(s.length===0)return null;const l=t.split("/").pop();return new _t(l,-1,s)}_getTimeSampledAttribute(t,e){const n=t+"."+e,s=this.specsByPath[n];if(s&&s.fields.timeSamples){const i=s.fields.timeSamples;if(i.times&&i.values)return i}return null}_flattenMatrixArray(t,e){if(!t||t.length===0)return null;if(typeof t[0]=="number")return t;const n=[];for(let s=0;s<e;s++)for(let i=0;i<4;i++){const r=t[s*4+i];r&&r.length===4?n.push(r[0],r[1],r[2],r[3]):n.push(i===0?1:0,i===1?1:0,i===2?1:0,i===3?1:0)}return n}}class Et extends Ut{constructor(t){super(t)}load(t,e,n,s){const i=this,r=new bt(i.manager);r.setPath(i.path),r.setResponseType("arraybuffer"),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(t,function(o){try{e(i.parse(o))}catch(l){s?s(l):console.error(l),i.manager.itemError(t)}},n,s)}parse(t){const e=new Ct,n=new zt;function s(u){const a={};new bt().setResponseType("arraybuffer");for(const d in u)if(d.endsWith("png")||d.endsWith("jpg")||d.endsWith("jpeg")){const m=d.endsWith("png")?"image/png":"image/jpeg",_=new Blob([u[d]],{type:m});a[d]=URL.createObjectURL(_)}for(const d in u)if(d.endsWith("usd")||d.endsWith("usda")||d.endsWith("usdc"))if(i(u[d])){const m=n.parseData(u[d].buffer);a[d]=m,a[d+":buffer"]=u[d].buffer}else{const m=new TextDecoder().decode(u[d]);a[d]=e.parseData(m),a[d+":text"]=m}return a}function i(u){const a=new Uint8Array([80,88,82,45,85,83,68,67]);if(u.byteLength<a.length)return!1;const p=new Uint8Array(u,0,a.length);for(let d=0;d<a.length;d++)if(p[d]!==a[d])return!1;return!0}function r(u){if(u.length<1)return{file:void 0,basePath:""};const a=Object.keys(u)[0];let p=!1;const d=a.lastIndexOf("/"),m=d>=0?a.slice(0,d):"";if(a.endsWith("usda"))return{file:u[a],basePath:m};if(a.endsWith("usdc"))p=!0;else if(a.endsWith("usd"))if(i(u[a]))p=!0;else return{file:u[a],basePath:m};return p?{file:u[a],basePath:m}:{file:void 0,basePath:""}}const o=this;if(typeof t=="string"){const u=new J(o.manager),a=e.parseData(t);return u.compose(a,{})}if(i(t)){const u=new J(o.manager),a=n.parseData(t);return u.compose(a,{})}const l=new Uint8Array(t);if(l[0]===80&&l[1]===75){const u=Bt(l),a=s(u),{file:p,basePath:d}=r(u),m=new J(o.manager);let _;if(i(p))_=n.parseData(p.buffer);else{const b=new TextDecoder().decode(p);_=e.parseData(b)}return m.compose(_,a,{},d)}const f=new J(o.manager),h=new TextDecoder().decode(l),c=e.parseData(h);return f.compose(c,{})}}export{Et as USDLoader};
